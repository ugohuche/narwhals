{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Narwhals","text":"<p>Extremely lightweight compatibility layer between Polars, pandas, and more.</p> <p>Seamlessly support both, without depending on either!</p> <ul> <li>\u2705 Just use a subset of the Polars API, no need to learn anything new</li> <li>\u2705 Zero dependencies, Narwhals only uses what   the user passes in so your library can stay lightweight</li> <li>\u2705 Separate lazy and eager APIs, use expressions</li> <li>\u2705 Support pandas' complicated type system and index, without   either getting in the way</li> <li>\u2705 100% branch coverage, tested against pandas and Polars nightly builds</li> <li>\u2705 Negligible overhead, see overhead</li> <li>\u2705 Let your IDE help you thanks to full static typing, see typing</li> <li>\u2705 Perfect backwards compatibility policy,   see stable api for how to opt-in</li> </ul>"},{"location":"#whos-this-for","title":"Who's this for?","text":"<p>Anyone wishing to write a library/application/service which consumes dataframes, and wishing to make it completely dataframe-agnostic.</p> <p>Let's get started!</p>"},{"location":"api-completeness/","title":"API Completeness","text":"<p>Narwhals has two different level of support for libraries: \"full\" and \"interchange\".</p> <p>Libraries for which we have full support we intend to support the whole Narwhals API, however this is a work in progress.</p> <p>In the following table it is possible to check which method is implemented for which backend. </p> <p>Info</p> <ul> <li>\"pandas-like\" means pandas, cuDF and Modin</li> <li>Polars supports all the methods (by design)</li> </ul> Class Method pandas-like arrow DataFrame clone DataFrame collect_schema DataFrame columns DataFrame drop DataFrame drop_nulls DataFrame filter DataFrame gather_every DataFrame get_column DataFrame group_by DataFrame head DataFrame is_duplicated DataFrame is_empty DataFrame is_unique DataFrame item DataFrame iter_rows DataFrame join DataFrame lazy DataFrame null_count DataFrame pipe DataFrame rename DataFrame rows DataFrame schema DataFrame select DataFrame shape DataFrame sort DataFrame tail DataFrame to_dict DataFrame to_numpy DataFrame to_pandas DataFrame unique DataFrame with_columns DataFrame with_row_index DataFrame write_parquet Expr abs Expr alias Expr all Expr any Expr arg_true Expr cast Expr cat Expr count Expr cum_sum Expr diff Expr drop_nulls Expr dt Expr fill_null Expr filter Expr gather_every Expr head Expr is_between Expr is_duplicated Expr is_first_distinct Expr is_in Expr is_last_distinct Expr is_null Expr is_unique Expr len Expr max Expr mean Expr min Expr n_unique Expr name Expr null_count Expr over Expr quantile Expr round Expr sample Expr shift Expr sort Expr std Expr str Expr sum Expr tail Expr unique ExprCatNamespace get_categories ExprDateTimeNamespace day ExprDateTimeNamespace hour ExprDateTimeNamespace microsecond ExprDateTimeNamespace millisecond ExprDateTimeNamespace minute ExprDateTimeNamespace month ExprDateTimeNamespace nanosecond ExprDateTimeNamespace ordinal_day ExprDateTimeNamespace second ExprDateTimeNamespace to_string ExprDateTimeNamespace total_microseconds ExprDateTimeNamespace total_milliseconds ExprDateTimeNamespace total_minutes ExprDateTimeNamespace total_nanoseconds ExprDateTimeNamespace total_seconds ExprDateTimeNamespace year ExprNameNamespace keep ExprNameNamespace map ExprNameNamespace prefix ExprNameNamespace suffix ExprNameNamespace to_lowercase ExprNameNamespace to_uppercase ExprStringNamespace contains ExprStringNamespace ends_with ExprStringNamespace head ExprStringNamespace slice ExprStringNamespace starts_with ExprStringNamespace tail ExprStringNamespace to_datetime ExprStringNamespace to_lowercase ExprStringNamespace to_uppercase LazyFrame clone LazyFrame collect LazyFrame collect_schema LazyFrame columns LazyFrame drop LazyFrame drop_nulls LazyFrame filter LazyFrame gather_every LazyFrame group_by LazyFrame head LazyFrame join LazyFrame lazy LazyFrame pipe LazyFrame rename LazyFrame schema LazyFrame select LazyFrame sort LazyFrame tail LazyFrame unique LazyFrame with_columns LazyFrame with_row_index Series abs Series alias Series all Series any Series arg_true Series cast Series cat Series count Series cum_sum Series diff Series drop_nulls Series dt Series dtype Series fill_null Series filter Series gather_every Series head Series is_between Series is_duplicated Series is_empty Series is_first_distinct Series is_in Series is_last_distinct Series is_null Series is_sorted Series is_unique Series item Series len Series max Series mean Series min Series n_unique Series name Series null_count Series quantile Series round Series sample Series shape Series shift Series sort Series std Series str Series sum Series tail Series to_dummies Series to_frame Series to_list Series to_numpy Series to_pandas Series unique Series value_counts Series zip_with SeriesCatNamespace get_categories SeriesDateTimeNamespace day SeriesDateTimeNamespace hour SeriesDateTimeNamespace microsecond SeriesDateTimeNamespace millisecond SeriesDateTimeNamespace minute SeriesDateTimeNamespace month SeriesDateTimeNamespace nanosecond SeriesDateTimeNamespace ordinal_day SeriesDateTimeNamespace second SeriesDateTimeNamespace to_string SeriesDateTimeNamespace total_microseconds SeriesDateTimeNamespace total_milliseconds SeriesDateTimeNamespace total_minutes SeriesDateTimeNamespace total_nanoseconds SeriesDateTimeNamespace total_seconds SeriesDateTimeNamespace year SeriesStringNamespace contains SeriesStringNamespace ends_with SeriesStringNamespace head SeriesStringNamespace slice SeriesStringNamespace starts_with SeriesStringNamespace tail SeriesStringNamespace to_lowercase SeriesStringNamespace to_uppercase"},{"location":"backcompat/","title":"Perfect backwards compatibility policy","text":"<p>Narwhals is primarily aimed at library maintainers rather than end users. As such, we need to take stability and backwards compatibility extra-seriously. Our policy is:</p> <ul> <li>If you write code using <code>import narwhals.stable.v1 as nw</code>, then we promise to   never change or remove any public function you're using.</li> <li>If we need to make a backwards-incompatible change, it will be pushed into   <code>narwhals.stable.v2</code>, leaving <code>narwhals.stable.v1</code> unaffected.</li> <li>We will maintain <code>narwhals.stable.v1</code> indefinitely, even as <code>narwhals.stable.v2</code> and other   stable APIs come out. For example, Narwhals version 1.0.0 will offer   <code>narwhals.stable.v1</code>, whereas Narwhals 2.0.0 will offer both <code>narwhals.stable.v1</code> and   <code>narwhals.stable.v2</code>.</li> </ul> <p>Like this, we enable different packages to be on different Narwhals stable APIs, and for end-users to use all of them in the same project without conflicts nor incompatibilities.</p>"},{"location":"backcompat/#background","title":"Background","text":"<p>Ever upgraded a package, only to find that it breaks all your tests because of an intentional API change? Did you end up having to litter your code with statements such as the following?</p> <pre><code>if parse_version(pdx.__version__) &lt; parse_version('1.3.0'):\n    df = df.brewbeer()\nelif parse_version('1.3.0') &lt;= parse_version(pdx.__version__) &lt; parse_version('1.5.0'):\n    df = df.brew_beer()\nelse:\n    df = df.brew_drink('beer')\n</code></pre> <p>Now imagine multiplying that complexity over all the dataframe libraries you want to support...</p> <p>Narwhals offers a simple solution, inspired by Rust editions.</p>"},{"location":"backcompat/#narwhals-stable-api","title":"Narwhals' Stable API","text":"<p>Narwhals implements a subset of the Polars API. What will Narwhals do if/when Polars makes a backwards-incompatible change? Would you need to update your Narwhals code?</p> <p>To understand the solution, let's go through an example. Suppose that, hypothetically, in Polars 2.0, <code>polars.Expr.cum_sum</code> was renamed to <code>polars.Expr.cumulative_sum</code>. In Narwhals, we have <code>narwhals.Expr.cum_sum</code>. Does this mean that Narwhals will also rename its method, and deprecate the old one? The answer is...no!</p> <p>Narwhals offers a <code>stable</code> namespace, which allows you to write your code once and forget about it. That is to say, if you write your code like this:</p> <pre><code>import narwhals.stable.v1 as nw\nfrom narwhals.typing import FrameT\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.with_columns(nw.col('a').cum_sum())\n</code></pre> <p>then we, in Narwhals, promise that your code will keep working, even in newer versions of Polars after they have renamed their method.</p> <p>Concretely, we would do the following:</p> <ul> <li><code>narwhals.stable.v1</code>: you can keep using <code>Expr.cum_sum</code></li> <li><code>narwhals.stable.v2</code>: you can only use <code>Expr.cumulative_sum</code>, <code>Expr.cum_sum</code> will have been removed</li> <li><code>narwhals</code>:  you can only use <code>Expr.cumulative_sum</code>, <code>Expr.cum_sum</code> will have been removed</li> </ul> <p>So, although Narwhals' main API (and <code>narwhals.stable.v2</code>) will have introduced a breaking change, users of <code>narwhals.stable.v1</code> will have their code unaffected.</p>"},{"location":"backcompat/#import-narwhals-as-nw-or-import-narwhalsstablev1-as-nw","title":"<code>import narwhals as nw</code> or <code>import narwhals.stable.v1 as nw</code>?","text":"<p>Which should you use? In general we recommend:</p> <ul> <li>When prototyping, use <code>import narwhals as nw</code>, so you can iterate quickly.</li> <li>Once you're happy with what you've got and what to release something production-ready and stable,   when switch out your <code>import narwhals as nw</code> usage for <code>import narwhals.stable.v1 as nw</code>.</li> </ul>"},{"location":"backcompat/#exceptions","title":"Exceptions","text":"<p>Are we really promising perfect backwards compatibility in all cases, without exceptions? Not quite. There are some exceptions, which we'll now list. But we'll never intentionally break your code. Anything currently in <code>narwhals.stable.v1</code> will not be changed or removed in future Narwhals versions.</p> <p>Here are exceptions to our backwards compatibility policy:</p> <ul> <li>unambiguous bugs. If a function contains what is unambiguously a bug, then we'll fix it, without   considering that to be a breaking change.</li> <li>radical changes in backends. Suppose that Polars was to remove   expressions, or pandas were to remove support for categorical data. At that point, we might   need to rethink Narwhals. However, we expect such radical changes to be exceedingly unlikely.</li> <li>we may consider making some type hints more precise.</li> </ul>"},{"location":"extending/","title":"List of supported libraries (and how to add yours!)","text":"<p>Currently, Narwhals supports the following libraries as inputs:</p> <ul> <li>pandas</li> <li>Polars</li> <li>cuDF</li> <li>Modin</li> <li>PyArrow</li> </ul> <p>If you want your own library to be recognised too, you're welcome open a PR (with tests)! Alternatively, if you can't do that (for example, if you library is closed-source), see the next section for what else you can do.</p> <p>To check which methods are supported for which backend in depth, please refer to the API completeness page.</p>"},{"location":"extending/#extending-narwhals","title":"Extending Narwhals","text":"<p>We love open source, but we're not \"open source absolutists\". If you're unable to open source you library, then this is how you can make your library compatible with Narwhals.</p> <p>Make sure that, in addition to the public Narwhals API, you also define:</p> <ul> <li><code>DataFrame.__narwhals_dataframe__</code>: return an object which implements public methods     from <code>Narwhals.DataFrame</code></li> <li><code>DataFrame.__narwhals_namespace__</code>: return an object which implements public top-level     functions from <code>narwhals</code> (e.g. <code>narwhals.col</code>, <code>narwhals.concat</code>, ...)</li> <li><code>LazyFrame.__narwhals_lazyframe__</code>: return an object which implements public methods     from <code>Narwhals.LazyFrame</code></li> <li><code>LazyFrame.__narwhals_namespace__</code>: return an object which implements public top-level     functions from <code>narwhals</code> (e.g. <code>narwhals.col</code>, <code>narwhals.concat</code>, ...)</li> <li><code>Series.__narwhals_series__</code>: return an object which implements public methods     from <code>Narwhals.Series</code></li> <li><code>Series.__narwhals_namespace__</code>: return an object which implements public top-level     functions from <code>narwhals</code> (e.g. <code>narwhals.col</code>, <code>narwhals.concat</code>, ...)</li> </ul> <p>If your library doesn't distinguish between lazy and eager, then it's OK for your dataframe   object to implement both <code>__narwhals_dataframe__</code> and <code>__narwhals_lazyframe__</code>. In fact,   that's currently what <code>narwhals._pandas_like.dataframe.PandasLikeDataFrame</code> does. So, if you're stuck,   take a look at the source code to see how it's done!</p> <p>Note that the \"extension\" mechanism is still experimental. If anything is not clear, or doesn't work, please do raise an issue or contact us on Discord (see the link on the README).</p>"},{"location":"how_it_works/","title":"How it works","text":""},{"location":"how_it_works/#theory","title":"Theory","text":"<p>You might think that Narwhals runs on underwater unicorn magic. However, this section exists to reassure you that there's no such thing. There's only one rule you need to understand in order to make sense of Narwhals:</p> <p>An expression is a function from a DataFrame to a sequence of Series.</p> <p>For example, <code>nw.col('a')</code> means \"given a dataframe <code>df</code>, give me the Series <code>'a'</code> from <code>df</code>\". Translating this to pandas syntax, we get:</p> <pre><code>def col_a(df):\n    return [df.loc[:, 'a']]\n</code></pre> <p>Let's step up the complexity. How about <code>nw.col('a')+1</code>? We already know what the <code>nw.col('a')</code> part looks like, so we just need to add <code>1</code> to each of its outputs:</p> <p></p> <p>Expressions can return multiple Series - for example, <code>nw.col('a', 'b')</code> translates to:</p> <p></p> <p>Expressions can also take multiple columns as input - for example, <code>nw.sum_horizontal('a', 'b')</code> translates to:</p> <p></p> <p>Note that although an expression may have multiple columns as input, those columns must all have been derived from the same dataframe. This last sentence was quite important, you might want to re-read it to make sure it sunk in.</p> <p>By itself, an expression doesn't produce a value. It only produces a value once you give it to a DataFrame context. What happens to the value(s) it produces depends on which context you hand it to:</p> <ul> <li><code>DataFrame.select</code>: produce a DataFrame with only the result of the given expression</li> <li><code>DataFrame.with_columns</code>: produce a DataFrame like the current one, but also with the result of   the given expression</li> <li><code>DataFrame.filter</code>: evaluate the given expression, and if it only returns a single Series, then   only keep rows where the result is <code>True</code>.</li> </ul> <p>Now let's turn our attention to the implementation.</p>"},{"location":"how_it_works/#pandas-implementation","title":"pandas implementation","text":"<p>The pandas namespace (<code>pd</code>) isn't Narwhals-compliant, as the pandas API is very different from Polars'. So...Narwhals implements a <code>PandasLikeNamespace</code>, which includes the top-level Polars functions included in the Narwhals API:</p> <p><pre><code>import pandas as pd\nimport narwhals as nw\nfrom narwhals._pandas_like.namespace import PandasLikeNamespace\nfrom narwhals._pandas_like.utils import Implementation\nfrom narwhals.utils import parse_version\n\npn = PandasLikeNamespace(\n    implementation=Implementation.PANDAS,\n    backend_version=parse_version(pd.__version__),\n)\nprint(nw.col('a')._call(pn))\n</code></pre> <pre><code>PandasLikeExpr(depth=0, function_name=col, root_names=['a'], output_names=['a']\n</code></pre> The result from the last line above is the same as we'd get from <code>pn.col('a')</code>, and it's a <code>narwhals._pandas_like.expr.PandasLikeExpr</code> object, which we'll call <code>PandasLikeExpr</code> for short.</p> <p><code>PandasLikeExpr</code> also has a <code>_call</code> method - but this one expects a <code>PandasLikeDataFrame</code> as input. Recall from above that an expression is a function from a dataframe to a sequence of series. The <code>_call</code> method gives us that function! Let's see it in action.</p> <p>Note: the following examples use <code>PandasLikeDataFrame</code> and <code>PandasLikeSeries</code>. These are backed by actual <code>pandas.DataFrame</code>s and <code>pandas.Series</code> respectively and are Narwhals-compliant. We can access the  underlying pandas objects via <code>PandasLikeDataFrame._native_dataframe</code> and <code>PandasLikeSeries._native_series</code>.</p> <pre><code>import narwhals as nw\nfrom narwhals._pandas_like.namespace import PandasLikeNamespace\nfrom narwhals._pandas_like.utils import Implementation\nfrom narwhals._pandas_like.dataframe import PandasLikeDataFrame\nfrom narwhals.utils import parse_version\nimport pandas as pd\n\npn = PandasLikeNamespace(\n    implementation=Implementation.PANDAS,\n    backend_version=parse_version(pd.__version__),\n)\n\ndf_pd = pd.DataFrame({'a': [1,2,3], 'b': [4,5,6]})\ndf = PandasLikeDataFrame(\n    df_pd,\n    implementation=Implementation.PANDAS,\n    backend_version=parse_version(pd.__version__),\n)\nexpression = pn.col('a') + 1\nresult = expression._call(df)\nprint(f'length of result: {len(result)}\\n')\nprint('native series of first value of result: ')\nprint([x._native_series for x in result][0])\n</code></pre> <pre><code>length of result: 1\n\nnative series of first value of result: \n0    2\n1    3\n2    4\nName: a, dtype: int64\n</code></pre> <p>So indeed, our expression did what it said on the tin - it took some dataframe, took column 'a', and added 1 to it.</p> <p>If you search for <code>def reuse_series_implementation</code>, you'll see that that's all expressions do in Narwhals - they just keep rigorously applying the definition of expression.</p> <p>It may look like there should be significant overhead to doing it this way - but really, it's just a few Python calls which get unwinded. From timing tests I've done, there's no detectable difference - in fact, because the Narwhals API guards against misusing the pandas API, it's likely that running pandas via Narwhals will in general be more efficient than running pandas directly.</p> <p>Further attempts at demistifying Narwhals, refactoring code so it's clearer, and explaining this section better are 110% welcome.</p>"},{"location":"how_it_works/#polars-and-other-implementations","title":"Polars and other implementations","text":"<p>Other implementations are similar to the above: their define their own Narwhals-compliant objects. So, all-in-all, there are a couple of layers here:</p> <ul> <li><code>nw.DataFrame</code> is backed by a Narwhals-compliant Dataframe, such as:</li> <li><code>narwhals._pandas_like.dataframe.PandasLikeDataFrame</code></li> <li><code>narwhals._arrow.dataframe.ArrowDataFrame</code></li> <li><code>narwhals._polars.dataframe.PolarsDataFrame</code></li> <li>each Narwhals-compliant DataFrame is backed by a native Dataframe, for example:</li> <li><code>narwhals._pandas_like.dataframe.PandasLikeDataFrame</code> is backed by a pandas DataFrame</li> <li><code>narwhals._arrow.dataframe.ArrowDataFrame</code> is backed by a PyArrow Table</li> <li><code>narwhals._polars.dataframe.PolarsDataFrame</code> is backed by a Polars DataFrame</li> </ul> <p>Each implementation defines its own objects in subfolders such as <code>narwhals._pandas_like</code>, <code>narwhals._arrow</code>, <code>narwhals._polars</code>, whereas the top-level modules such as <code>narwhals.dataframe</code> and <code>narwhals.series</code> coordinate how to dispatch the Narwhals API to each backend.</p>"},{"location":"how_it_works/#group-by","title":"Group-by","text":"<p>Group-by is probably one of Polars' most significant innovations (on the syntax side) with respect to pandas. We can write something like <pre><code>df: pl.DataFrame\ndf.group_by('a').agg((pl.col('c') &gt; pl.col('b').mean()).max())\n</code></pre> To do this in pandas, we need to either use <code>GroupBy.apply</code> (sloooow), or do some crazy manual optimisations to get it to work.</p> <p>In Narwhals, here's what we do:</p> <ul> <li>if somebody uses a simple group-by aggregation (e.g. <code>df.group_by('a').agg(nw.col('b').mean())</code>),   then on the pandas side we translate it to   <pre><code>df: pd.DataFrame\ndf.groupby('a').agg({'b': ['mean']})\n</code></pre></li> <li>if somebody passes a complex group-by aggregation, then we use <code>apply</code> and raise a <code>UserWarning</code>, warning   users of the performance penalty and advising them to refactor their code so that the aggregation they perform   ends up being a simple one.</li> </ul> <p>In order to tell whether an aggregation is simple, Narwhals uses the private <code>_depth</code> attribute of <code>PandasLikeExpr</code>:</p> <pre><code>print(pn.col('a').mean())\nprint((pn.col('a')+1).mean())\nprint(pn.mean('a'))\n</code></pre> <pre><code>PandasLikeExpr(depth=1, function_name=col-&gt;mean, root_names=['a'], output_names=['a']\nPandasLikeExpr(depth=2, function_name=col-&gt;__add__-&gt;mean, root_names=['a'], output_names=['a']\nPandasLikeExpr(depth=1, function_name=col-&gt;mean, root_names=['a'], output_names=['a']\n</code></pre> <p>For simple aggregations, Narwhals can just look at <code>_depth</code> and <code>function_name</code> and figure out which (efficient) elementary operation this corresponds to in pandas.</p>"},{"location":"installation/","title":"Installation","text":"<p>First, make sure you have created and activated a Python3.8+ virtual environment.</p> <p>Then, run <pre><code>python -m pip install narwhals\n</code></pre></p> <p>Then, if you start the Python REPL and see the following: <pre><code>&gt;&gt;&gt; import narwhals\n&gt;&gt;&gt; narwhals.__version__\n'1.1.7'\n</code></pre> then installation worked correctly!</p>"},{"location":"levels/","title":"Levels","text":"<p>Narwhals comes with two levels of support: \"full\" and \"interchange\".</p> <p>Libraries for which we have full support can benefit from the whole Narwhals API.</p> <p>For example:</p> <p><pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.group_by('a').agg(\n        b_mean=nw.col('b').mean(),\n        b_std=nw.col('b').std(),\n    )\n</code></pre> will work for any of pandas, Polars, cuDF, Modin, and PyArrow.</p> <p>However, sometimes you don't need to do complex operations on dataframes - all you need is to inspect the schema a bit before making other decisions, such as which columns to select or whether to convert to another library. For that purpose, we also provide \"interchange\" level of support. If a library implements the Dataframe Interchange Protocol, then a call such as</p> <p><pre><code>from typing import Any\n\nimport narwhals as nw\nfrom narwhals.schema import Schema\n\n\ndef func(df: Any) -&gt; Schema:\n    df = nw.from_native(df, eager_or_interchange_only=True)\n    return df.schema\n</code></pre> is also supported, meaning that, in addition to the libraries mentioned above, you can also pass Ibis, Vaex, PyArrow, and any other library which implements the protocol.</p>"},{"location":"overhead/","title":"Overhead","text":"<p>Narwhals converts Polars syntax to non-Polars dataframes.</p> <p>So, what's the overhead of running pandas vs pandas via Narwhals?</p> <p>Based on experiments we've done, the answer is: it's negligible. Here are timings from the TPC-H queries, comparing running pandas directly vs running pandas via Narwhals:</p> <p></p> <p>Here's the code to reproduce the plot above, check the input sources for notebooks which run each individual query, along with the data sources.</p> <p>On some runs, the Narwhals code makes things marginally faster, on others marginally slower. The overall picture is clear: with Narwhals, you can support both Polars and pandas APIs with little to no impact on either.</p>"},{"location":"quick_start/","title":"Quick start","text":""},{"location":"quick_start/#prerequisites","title":"Prerequisites","text":"<p>Please start by following the installation instructions.</p> <p>To follow along with the examples which follow, please install the following (though note that they are not required dependencies - Narwhals only ever uses what the user passes in):</p> <ul> <li>pandas</li> <li>Polars</li> </ul>"},{"location":"quick_start/#simple-example","title":"Simple example","text":"<p>Create a Python file <code>t.py</code> with the following content:</p> <pre><code>from __future__ import annotations\n\nimport pandas as pd\nimport polars as pl\nimport narwhals as nw\nfrom narwhals.typing import IntoFrame\n\n\ndef my_function(df_native: IntoFrame) -&gt; list[str]:\n    df = nw.from_native(df_native)\n    column_names = df.columns\n    return column_names\n\n\ndf_pandas = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\ndf_polars = pl.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\n\nprint('pandas output')\nprint(my_function(df_pandas))\nprint('Polars output')\nprint(my_function(df_polars))\n</code></pre> <pre><code>pandas output\n['a', 'b']\nPolars output\n['a', 'b']\n</code></pre> <p>If you run <code>python t.py</code> then your output should look like the above. This is the simplest possible example of a dataframe-agnostic function - as we'll soon see, we can do much more advanced things. Let's learn about what you just did, and what Narwhals can do for you!</p> <p>Note: these examples are only using pandas and Polars. Please see the following to find the supported libriaries.</p>"},{"location":"related/","title":"Related projects","text":""},{"location":"related/#dataframe-interchange-protocol","title":"Dataframe Interchange Protocol","text":"<p>Standardised way of interchanging data between libraries, see here.</p> <p>Narwhals builds upon it by providing one level of support to libraries which implement it - this includes Ibis and Vaex. See levels for details.</p>"},{"location":"related/#array-api","title":"Array API","text":"<p>Array counterpart to the DataFrame API, see here.</p>"},{"location":"roadmap/","title":"Roadmap","text":"<p>Priorities, as of July 2024, are:</p> <ul> <li>Works towards supporting projects which have shown interest in Narwhals: scikit-learn, shiny, tubular</li> <li>Implement when/then/otherwise so that Narwhals is API-complete enough to complete all the TPC-H queries</li> <li>Add support for extra backends such as Dask</li> <li>Add extra docs and tutorials to make the project more accessible and easy to get started with</li> </ul>"},{"location":"why/","title":"Why?","text":"<p>You may think that pandas, Polars, and all dataframe libraries are quite similar. But are they really?</p> <p>For example, do the following produce the same output?</p> <pre><code>import pandas as pd\nimport polars as pl\n\nprint(3 in pd.Series([1, 2, 3]))\nprint(3 in pl.Series([1, 2, 3]))\n</code></pre> <p>Try it out and see ;) Spoiler alert: they don't. pandas checks if <code>3</code> is in the index, Polars checks if it's in the values.</p> <p>For another example, try running the code below - note how the outputs have different column names after the join!</p> <pre><code>pd_df_left = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\npd_df_right = pd.DataFrame({'a': [1, 2, 3], 'c': [4, 5, 6]})\npd_left_merge = pd_df_left.merge(pd_df_right, left_on='b', right_on='c', how='left')\n\npl_df_left = pl.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 6]})\npl_df_right = pl.DataFrame({'a': [1, 2, 3], 'c': [4, 5, 6]})\npl_left_merge = pl_df_left.join(pl_df_right, left_on='b', right_on='c', how='left')\n\nprint(pd_left_merge.columns)\nprint(pl_df_right.columns)\n</code></pre> <p>There are several such subtle difference between the libraries. Writing dataframe-agnostic code is hard! But by having a unified, simple, and predictable API, you can focus on behaviour rather than on subtle implementation differences.</p> <p>Furthermore, both pandas and Polars frequently deprecate behaviour. Narwhals handles this for you by testing against nightly builds of both libraries and handling backwards compatibility internally  (so you don't have to!).</p>"},{"location":"api-reference/","title":"API Reference","text":"<p>Anything documented in the API reference is intended to work consistently among supported backends.</p> <p>For example: <pre><code>import narwhals as nw\n\ndf.with_columns(\n    a_mean = nw.col('a').mean(),\n    a_std = nw.col('a').std(),\n)\n</code></pre> is supported, as <code>DataFrame.with_columns</code>, <code>narwhals.col</code>, <code>Expr.mean</code>, and <code>Expr.std</code> are all documented in the API reference.</p> <p>However, <pre><code>import narwhals as nw\n\ndf.with_columns(\n    a_ewm_mean = nw.col('a').ewm_mean(alpha=.7),\n)\n</code></pre> is not - <code>Expr.ewm_mean</code> only appears in the Polars API reference, but not in the Narwhals one.</p> <p>In general, you should expect any fundamental dataframe operation to be supported - if one that you need is not, please do open a feature request!</p>"},{"location":"api-reference/dataframe/","title":"<code>narwhals.DataFrame</code>","text":"<p>Narwhals DataFrame, backed by a native dataframe.</p> <p>The native dataframe might be pandas.DataFrame, polars.DataFrame, ...</p> <p>This class is not meant to be instantiated directly - instead, use <code>narwhals.from_native</code>.</p>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.columns","title":"<code>columns: list[str]</code>  <code>property</code>","text":"<p>Get column names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.columns\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n['foo', 'bar', 'ham']\n&gt;&gt;&gt; func(df_pl)\n['foo', 'bar', 'ham']\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.schema","title":"<code>schema: Schema</code>  <code>property</code>","text":"<p>Get an ordered mapping of column names to their data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6.0, 7.0, 8.0],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.schema\n</code></pre> <p>You can pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; df_pd_schema = func(df_pd)\n&gt;&gt;&gt; df_pd_schema\nSchema({'foo': Int64, 'bar': Float64, 'ham', String})\n</code></pre> <pre><code>&gt;&gt;&gt; df_pl_schema = func(df_pl)\n&gt;&gt;&gt; df_pl_schema\nSchema({'foo': Int64, 'bar': Float64, 'ham', String})\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.shape","title":"<code>shape: tuple[int, int]</code>  <code>property</code>","text":"<p>Get the shape of the DataFrame.</p> <p>Examples:</p> <p>Construct pandas and polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3, 4, 5]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.shape\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n(5, 1)\n&gt;&gt;&gt; func(df_pl)\n(5, 1)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.__getitem__","title":"<code>__getitem__(item)</code>","text":"<p>Extract column or slice of DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str | slice | Sequence[int] | tuple[Sequence[int], str | int] | tuple[Sequence[int], Sequence[int] | Sequence[str]]</code> <p>how to slice dataframe:</p> <ul> <li>str: extract column</li> <li>slice or Sequence of integers: slice rows from dataframe.</li> <li>tuple of Sequence of integers and str or int: slice rows and extract column at the same time.</li> <li>tuple of Sequence of integers and Sequence of integers: slice rows and extract columns at the same time.</li> </ul> required <p>Notes:     Integers are always interpreted as positions, and strings always as column names.</p> <pre><code>In contrast with Polars, pandas allows non-string column names.\nIf you don't know whether the column name you're trying to extract\nis definitely a string (e.g. `df[df.columns[0]]`) then you should\nuse `DataFrame.get_column` instead.\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [3, 4]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify(eager_only=True)\n... def func(df):\n...     return df[\"a\"]\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n0    1\n1    2\nName: a, dtype: int64\n&gt;&gt;&gt; func(df_pl)\nshape: (2,)\nSeries: 'a' [i64]\n[\n    1\n    2\n]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.clone","title":"<code>clone()</code>","text":"<p>Create a copy of this DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [3, 4]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we clone the DataFrame:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.clone()\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  3\n1  2  4\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 3   \u2502\n\u2502 2   \u2506 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.collect_schema","title":"<code>collect_schema()</code>","text":"<p>Get an ordered mapping of column names to their data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6.0, 7.0, 8.0],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.collect_schema()\n</code></pre> <p>You can pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; df_pd_schema = func(df_pd)\n&gt;&gt;&gt; df_pd_schema\nSchema({'foo': Int64, 'bar': Float64, 'ham', String})\n</code></pre> <pre><code>&gt;&gt;&gt; df_pl_schema = func(df_pl)\n&gt;&gt;&gt; df_pl_schema\nSchema({'foo': Int64, 'bar': Float64, 'ham', String})\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.drop","title":"<code>drop(*columns)</code>","text":"<p>Remove columns from the dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>*columns</code> <code>str | Iterable[str]</code> <p>Names of the columns that should be removed from the dataframe.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.drop(\"ham\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1  6.0\n1    2  7.0\n2    3  8.0\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6.0 \u2502\n\u2502 2   \u2506 7.0 \u2502\n\u2502 3   \u2506 8.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use positional arguments to drop multiple columns.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.drop(\"foo\", \"ham\")\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pd)\n   bar\n0  6.0\n1  7.0\n2  8.0\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 bar \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 6.0 \u2502\n\u2502 7.0 \u2502\n\u2502 8.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.drop_nulls","title":"<code>drop_nulls()</code>","text":"<p>Drop null values.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1.0, 2.0, None], \"ba\": [1.0, None, 2.0]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.drop_nulls()\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a   ba\n0  1.0  1.0\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 ba  \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 f64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0 \u2506 1.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.filter","title":"<code>filter(*predicates)</code>","text":"<p>Filter the rows in the DataFrame based on one or more predicate expressions.</p> <p>The original order of the remaining rows is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>predicates</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Expression(s) that evaluates to a boolean Series.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6, 7, 8],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we filter on one condition.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter(nw.col(\"foo\") &gt; 1)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n1    2    7   b\n2    3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 7   \u2506 b   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter on multiple conditions, combined with and/or operators:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter((nw.col(\"foo\") &lt; 3) &amp; (nw.col(\"ham\") == \"a\"))\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter((nw.col(\"foo\") == 1) | (nw.col(\"ham\") == \"c\"))\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n2    3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Provide multiple filters using <code>*args</code> syntax:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     dframe = df.filter(\n...         nw.col(\"foo\") &lt;= 2,\n...         ~nw.col(\"ham\").is_in([\"b\", \"c\"]),\n...     )\n...     return dframe\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.gather_every","title":"<code>gather_every(n, offset=0)</code>","text":"<p>Take every nth row in the DataFrame and return as a new DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Gather every n-th row.</p> required <code>offset</code> <code>int</code> <p>Starting index.</p> <code>0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 4], \"b\": [5, 6, 7, 8]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function in which gather every 2 rows, starting from a offset of 1:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df_any):\n...     return df_any.gather_every(n=2, offset=1)\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n1  2  6\n3  4  8\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 6   \u2502\n\u2502 4   \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.get_column","title":"<code>get_column(name)</code>","text":"<p>Get a single column by name.</p> Notes <p>Although <code>name</code> is typed as <code>str</code>, pandas does allow non-string column names, and they will work when passed to this function if the <code>narwhals.DataFrame</code> is backed by a pandas dataframe with non-string columns. This function can only be used to extract a column by name, so there is no risk of ambiguity.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [3, 4]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify(eager_only=True)\n... def func(df):\n...     name = df.columns[0]\n...     return df.get_column(name)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n0    1\n1    2\nName: a, dtype: int64\n&gt;&gt;&gt; func(df_pl)\nshape: (2,)\nSeries: 'a' [i64]\n[\n    1\n    2\n]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.group_by","title":"<code>group_by(*keys)</code>","text":"<p>Start a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <code>str | Iterable[str]</code> <p>Column(s) to group by. Accepts multiple columns names as a list.</p> <code>()</code> <p>Returns:</p> Name Type Description <code>GroupBy</code> <code>GroupBy[Self]</code> <p>Object which can be used to perform aggregations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...     \"b\": [1, 2, 1, 3, 3],\n...     \"c\": [5, 4, 3, 2, 1],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we group by one column and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.group_by(\"a\").agg(nw.col(\"b\").sum()).sort(\"a\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  a  2\n1  b  5\n2  c  3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 2   \u2502\n\u2502 b   \u2506 5   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Group by multiple columns by passing a list of column names.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.group_by([\"a\", \"b\"]).agg(nw.max(\"c\")).sort(\"a\", \"b\")\n&gt;&gt;&gt; func(df_pd)\n   a  b  c\n0  a  1  5\n1  b  2  4\n2  b  3  2\n3  c  3  1\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2506 5   \u2502\n\u2502 b   \u2506 2   \u2506 4   \u2502\n\u2502 b   \u2506 3   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.head","title":"<code>head(n=5)</code>","text":"<p>Get the first <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return. If a negative value is passed, return all rows except the last <code>abs(n)</code>.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3, 4, 5],\n...     \"bar\": [6, 7, 8, 9, 10],\n...     \"ham\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function that gets the first 3 rows.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.head(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n1    2    7   b\n2    3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2502 2   \u2506 7   \u2506 b   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_duplicated","title":"<code>is_duplicated()</code>","text":"<p>Get a mask of all duplicated rows in this DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"a\": [1, 2, 3, 1],\n...         \"b\": [\"x\", \"y\", \"z\", \"x\"],\n...     }\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\n...         \"a\": [1, 2, 3, 1],\n...         \"b\": [\"x\", \"y\", \"z\", \"x\"],\n...     }\n... )\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.is_duplicated()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n0     True\n1    False\n2    False\n3     True\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4,)\nSeries: '' [bool]\n[\n    true\n    false\n    false\n    true\n]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_empty","title":"<code>is_empty()</code>","text":"<p>Check if the dataframe is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <p>Let's define a dataframe-agnostic function that filters rows in which \"foo\" values are greater than 10, and then checks if the result is empty or not:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter(nw.col(\"foo\") &gt; 10).is_empty()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": [4, 5, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"foo\": [1, 2, 3], \"bar\": [4, 5, 6]})\n&gt;&gt;&gt; func(df_pd), func(df_pl)\n(True, True)\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"foo\": [100, 2, 3], \"bar\": [4, 5, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"foo\": [100, 2, 3], \"bar\": [4, 5, 6]})\n&gt;&gt;&gt; func(df_pd), func(df_pl)\n(False, False)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.is_unique","title":"<code>is_unique()</code>","text":"<p>Get a mask of all unique rows in this DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"a\": [1, 2, 3, 1],\n...         \"b\": [\"x\", \"y\", \"z\", \"x\"],\n...     }\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\n...         \"a\": [1, 2, 3, 1],\n...         \"b\": [\"x\", \"y\", \"z\", \"x\"],\n...     }\n... )\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.is_unique()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n0    False\n1     True\n2     True\n3    False\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4,)\nSeries: '' [bool]\n[\n    false\n     true\n     true\n    false\n]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.item","title":"<code>item(row=None, column=None)</code>","text":"<p>Return the DataFrame as a scalar, or return the element at the given row/column.</p> Notes <p>If row/col not provided, this is equivalent to df[0,0], with a check that the shape is (1,1). With row/col, this is equivalent to df[row,col].</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [4, 5, 6]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that returns item at given row/column</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df, row, column):\n...     return df.item(row, column)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd, 1, 1), func(df_pd, 2, \"b\")\n(5, 6)\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl, 1, 1), func(df_pl, 2, \"b\")\n(5, 6)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.iter_rows","title":"<code>iter_rows(*, named=False, buffer_size=512)</code>","text":"<p>Returns an iterator over the DataFrame of rows of python-native values.</p> <p>Parameters:</p> Name Type Description Default <code>named</code> <code>bool</code> <p>By default, each row is returned as a tuple of values given in the same order as the frame columns. Setting named=True will return rows of dictionaries instead.</p> <code>False</code> <code>buffer_size</code> <code>int</code> <p>Determines the number of rows that are buffered internally while iterating over the data. See https://docs.pola.rs/api/python/stable/reference/dataframe/api/polars.DataFrame.iter_rows.html</p> <code>512</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df, *, named):\n...     return df.iter_rows(named=named)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; [row for row in func(df_pd, named=False)]\n[(1, 6.0, 'a'), (2, 7.0, 'b'), (3, 8.0, 'c')]\n&gt;&gt;&gt; [row for row in func(df_pd, named=True)]\n[{'foo': 1, 'bar': 6.0, 'ham': 'a'}, {'foo': 2, 'bar': 7.0, 'ham': 'b'}, {'foo': 3, 'bar': 8.0, 'ham': 'c'}]\n&gt;&gt;&gt; [row for row in func(df_pl, named=False)]\n[(1, 6.0, 'a'), (2, 7.0, 'b'), (3, 8.0, 'c')]\n&gt;&gt;&gt; [row for row in func(df_pl, named=True)]\n[{'foo': 1, 'bar': 6.0, 'ham': 'a'}, {'foo': 2, 'bar': 7.0, 'ham': 'b'}, {'foo': 3, 'bar': 8.0, 'ham': 'c'}]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.join","title":"<code>join(other, *, how='inner', left_on=None, right_on=None)</code>","text":"<p>Join in SQL-like fashion.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>DataFrame to join with.</p> required <code>how</code> <code>Literal['inner', 'left', 'cross', 'semi', 'anti']</code> <p>Join strategy.</p> <ul> <li>inner: Returns rows that have matching values in both tables.</li> <li>cross: Returns the Cartesian product of rows from both tables.</li> <li>semi: Filter rows that have a match in the right table.</li> <li>anti: Filter rows that do not have a match in the right table.</li> </ul> <code>'inner'</code> <code>left_on</code> <code>str | list[str] | None</code> <p>Name(s) of the left join column(s).</p> <code>None</code> <code>right_on</code> <code>str | list[str] | None</code> <p>Name(s) of the right join column(s).</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new joined DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6.0, 7.0, 8.0],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; data_other = {\n...     \"apple\": [\"x\", \"y\", \"z\"],\n...     \"ham\": [\"a\", \"b\", \"d\"],\n... }\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; other_pd = pd.DataFrame(data_other)\n</code></pre> <pre><code>&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n&gt;&gt;&gt; other_pl = pl.DataFrame(data_other)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we join over \"ham\" column:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def join_on_ham(df, other_any):\n...     return df.join(other_any, left_on=\"ham\", right_on=\"ham\")\n</code></pre> <p>We can now pass either pandas or Polars to the function:</p> <pre><code>&gt;&gt;&gt; join_on_ham(df_pd, other_pd)\n   foo  bar ham apple\n0    1  6.0   a     x\n1    2  7.0   b     y\n</code></pre> <pre><code>&gt;&gt;&gt; join_on_ham(df_pl, other_pl)\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2506 apple \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 f64 \u2506 str \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6.0 \u2506 a   \u2506 x     \u2502\n\u2502 2   \u2506 7.0 \u2506 b   \u2506 y     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.lazy","title":"<code>lazy()</code>","text":"<p>Lazify the DataFrame (if possible).</p> <p>If a library does not support lazy execution, then this is a no-op.</p> <p>Examples:</p> <p>Construct pandas and Polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.lazy()\n</code></pre> <p>Note that then, pandas dataframe stay eager, but Polars DataFrame becomes a Polars LazyFrame:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1  6.0   a\n1    2  7.0   b\n2    3  8.0   c\n&gt;&gt;&gt; func(df_pl)\n&lt;LazyFrame ...&gt;\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.null_count","title":"<code>null_count()</code>","text":"<p>Create a new DataFrame that shows the null counts per column.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"foo\": [1, None, 3],\n...         \"bar\": [6, 7, None],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\n...         \"foo\": [1, None, 3],\n...         \"bar\": [6, 7, None],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the null count of each columns:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.null_count()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar  ham\n0    1    1    0\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 u32 \u2506 u32 \u2506 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 1   \u2506 0   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Pipe function call.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"ba\": [4, 5, 6]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.pipe(\n...         lambda _df: _df.select([x for x in _df.columns if len(x) == 1])\n...     )\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  1\n1  2\n2  3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.rename","title":"<code>rename(mapping)</code>","text":"<p>Rename column names.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, str]</code> <p>Key value pairs that map from old name to new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6, 7, 8], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.rename({\"foo\": \"apple\"})\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   apple  bar ham\n0      1    6   a\n1      2    7   b\n2      3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 apple \u2506 bar \u2506 ham \u2502\n\u2502 ---   \u2506 --- \u2506 --- \u2502\n\u2502 i64   \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1     \u2506 6   \u2506 a   \u2502\n\u2502 2     \u2506 7   \u2506 b   \u2502\n\u2502 3     \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.rows","title":"<code>rows(*, named=False)</code>","text":"<p>Returns all data in the DataFrame as a list of rows of python-native values.</p> <p>Parameters:</p> Name Type Description Default <code>named</code> <code>bool</code> <p>By default, each row is returned as a tuple of values given in the same order as the frame columns. Setting named=True will return rows of dictionaries instead.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df, *, named):\n...     return df.rows(named=named)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd, named=False)\n[(1, 6.0, 'a'), (2, 7.0, 'b'), (3, 8.0, 'c')]\n&gt;&gt;&gt; func(df_pd, named=True)\n[{'foo': 1, 'bar': 6.0, 'ham': 'a'}, {'foo': 2, 'bar': 7.0, 'ham': 'b'}, {'foo': 3, 'bar': 8.0, 'ham': 'c'}]\n&gt;&gt;&gt; func(df_pl, named=False)\n[(1, 6.0, 'a'), (2, 7.0, 'b'), (3, 8.0, 'c')]\n&gt;&gt;&gt; func(df_pl, named=True)\n[{'foo': 1, 'bar': 6.0, 'ham': 'a'}, {'foo': 2, 'bar': 7.0, 'ham': 'b'}, {'foo': 3, 'bar': 8.0, 'ham': 'c'}]\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.select","title":"<code>select(*exprs, **named_exprs)</code>","text":"<p>Select columns from this DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to select, specified as positional arguments.      Accepts expression input. Strings are parsed as column names,      other non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to select, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6, 7, 8],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we pass the name of a column to select that column.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\"foo\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo\n0    1\n1    2\n2    3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Multiple columns can be selected by passing a list of column names.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select([\"foo\", \"bar\"])\n&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1    6\n1    2    7\n2    3    8\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2502\n\u2502 2   \u2506 7   \u2502\n\u2502 3   \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Multiple columns can also be selected using positional arguments instead of a list. Expressions are also accepted.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"foo\"), nw.col(\"bar\") + 1)\n&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1    7\n1    2    8\n2    3    9\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 7   \u2502\n\u2502 2   \u2506 8   \u2502\n\u2502 3   \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use keyword arguments to easily name your expression inputs.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(threshold=nw.col(\"foo\") * 2)\n&gt;&gt;&gt; func(df_pd)\n   threshold\n0          2\n1          4\n2          6\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 threshold \u2502\n\u2502 ---       \u2502\n\u2502 i64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2         \u2502\n\u2502 4         \u2502\n\u2502 6         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.sort","title":"<code>sort(by, *more_by, descending=False)</code>","text":"<p>Sort the dataframe by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | Iterable[str]</code> <p>Column(s) names to sort by.</p> required <code>*more_by</code> <code>str</code> <p>Additional columns to sort by, specified as positional        arguments.</p> <code>()</code> <code>descending</code> <code>bool | Sequence[bool]</code> <p>Sort in descending order. When sorting by multiple          columns, can be specified per column by passing a          sequence of booleans.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\n...     \"a\": [1, 2, None],\n...     \"b\": [6.0, 5.0, 4.0],\n...     \"c\": [\"a\", \"c\", \"b\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we sort by multiple columns in different orders</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.sort(\"c\", \"a\", descending=[False, True])\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a    b  c\n0  1.0  6.0  a\n2  NaN  4.0  b\n1  2.0  5.0  c\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 c   \u2502\n\u2502 ---  \u2506 --- \u2506 --- \u2502\n\u2502 i64  \u2506 f64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0 \u2506 a   \u2502\n\u2502 null \u2506 4.0 \u2506 b   \u2502\n\u2502 2    \u2506 5.0 \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.tail","title":"<code>tail(n=5)</code>","text":"<p>Get the last <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return. If a negative value is passed, return all rows except the first <code>abs(n)</code>.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3, 4, 5],\n...     \"bar\": [6, 7, 8, 9, 10],\n...     \"ham\": [\"a\", \"b\", \"c\", \"d\", \"e\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function that gets the last 3 rows.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.tail(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n2    3    8   c\n3    4    9   d\n4    5   10   e\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2502 4   \u2506 9   \u2506 d   \u2502\n\u2502 5   \u2506 10  \u2506 e   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_dict","title":"<code>to_dict(*, as_series=True)</code>","text":"<p>Convert DataFrame to a dictionary mapping column name to values.</p> <p>Parameters:</p> Name Type Description Default <code>as_series</code> <code>bool</code> <p>If set to true <code>True</code>, then the values are Narwhals Series,         otherwise the values are Any.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"A\": [1, 2, 3, 4, 5],\n...     \"fruits\": [\"banana\", \"banana\", \"apple\", \"apple\", \"banana\"],\n...     \"B\": [5, 4, 3, 2, 1],\n...     \"cars\": [\"beetle\", \"audi\", \"beetle\", \"beetle\", \"beetle\"],\n...     \"optional\": [28, 300, None, 2, -30],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.to_dict(as_series=False)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n{'A': [1, 2, 3, 4, 5], 'fruits': ['banana', 'banana', 'apple', 'apple', 'banana'], 'B': [5, 4, 3, 2, 1], 'cars': ['beetle', 'audi', 'beetle', 'beetle', 'beetle'], 'optional': [28.0, 300.0, nan, 2.0, -30.0]}\n&gt;&gt;&gt; func(df_pl)\n{'A': [1, 2, 3, 4, 5], 'fruits': ['banana', 'banana', 'apple', 'apple', 'banana'], 'B': [5, 4, 3, 2, 1], 'cars': ['beetle', 'audi', 'beetle', 'beetle', 'beetle'], 'optional': [28, 300, None, 2, -30]}\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_numpy","title":"<code>to_numpy()</code>","text":"<p>Convert this DataFrame to a NumPy ndarray.</p> <p>Examples:</p> <p>Construct pandas and polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.5, 7.0, 8.5], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.to_numpy()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\narray([[1, 6.5, 'a'],\n       [2, 7.0, 'b'],\n       [3, 8.5, 'c']], dtype=object)\n&gt;&gt;&gt; func(df_pl)\narray([[1, 6.5, 'a'],\n       [2, 7.0, 'b'],\n       [3, 8.5, 'c']], dtype=object)\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.to_pandas","title":"<code>to_pandas()</code>","text":"<p>Convert this DataFrame to a pandas DataFrame.</p> <p>Examples:</p> <p>Construct pandas and Polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.to_pandas()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1  6.0   a\n1    2  7.0   b\n2    3  8.0   c\n&gt;&gt;&gt; func(df_pl)\n   foo  bar ham\n0    1  6.0   a\n1    2  7.0   b\n2    3  8.0   c\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.unique","title":"<code>unique(subset=None, *, keep='any', maintain_order=False)</code>","text":"<p>Drop duplicate rows from this dataframe.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str] | None</code> <p>Column name(s) to consider when identifying duplicate rows.</p> <code>None</code> <code>keep</code> <code>Literal['any', 'first', 'last', 'none']</code> <p>{'first', 'last', 'any', 'none'} Which of the duplicate rows to keep.</p> <ul> <li>'any': Does not give any guarantee of which row is kept.         This allows more optimizations.</li> <li>'none': Don't keep duplicate rows.</li> <li>'first': Keep first unique row.</li> <li>'last': Keep last unique row.</li> </ul> <code>'any'</code> <code>maintain_order</code> <code>bool</code> <p>Keep the same order as the original DataFrame. This is more expensive to compute. Settings this to <code>True</code> blocks the possibility to run on the streaming engine for polars.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"foo\": [1, 2, 3, 1],\n...     \"bar\": [\"a\", \"a\", \"a\", \"a\"],\n...     \"ham\": [\"b\", \"b\", \"b\", \"b\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.unique([\"bar\", \"ham\"])\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo bar ham\n0    1   a   b\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 str \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 a   \u2506 b   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.with_columns","title":"<code>with_columns(*exprs, **named_exprs)</code>","text":"<p>Add columns to this DataFrame.</p> <p>Added columns will replace existing columns with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to add, specified as positional arguments.      Accepts expression input. Strings are parsed as column names, other      non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to add, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>DataFrame</code> <code>Self</code> <p>A new DataFrame with the columns added.</p> Note <p>Creating a new DataFrame using this method does not create a new copy of existing data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"a\": [1, 2, 3, 4],\n...     \"b\": [0.5, 4, 10, 13],\n...     \"c\": [True, True, False, True],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we pass an expression to add it as a new column:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns((nw.col(\"a\") * 2).alias(\"a*2\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a     b      c  a*2\n0  1   0.5   True    2\n1  2   4.0   True    4\n2  3  10.0  False    6\n3  4  13.0   True    8\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b    \u2506 c     \u2506 a*2 \u2502\n\u2502 --- \u2506 ---  \u2506 ---   \u2506 --- \u2502\n\u2502 i64 \u2506 f64  \u2506 bool  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 0.5  \u2506 true  \u2506 2   \u2502\n\u2502 2   \u2506 4.0  \u2506 true  \u2506 4   \u2502\n\u2502 3   \u2506 10.0 \u2506 false \u2506 6   \u2502\n\u2502 4   \u2506 13.0 \u2506 true  \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.with_row_index","title":"<code>with_row_index(name='index')</code>","text":"<p>Insert column which enumerates rows.</p> <p>Examples:</p> <p>Construct pandas as polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [4, 5, 6]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_row_index()\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   index  a  b\n0      0  1  4\n1      1  2  5\n2      2  3  6\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 index \u2506 a   \u2506 b   \u2502\n\u2502 ---   \u2506 --- \u2506 --- \u2502\n\u2502 u32   \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0     \u2506 1   \u2506 4   \u2502\n\u2502 1     \u2506 2   \u2506 5   \u2502\n\u2502 2     \u2506 3   \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/dataframe/#narwhals.dataframe.DataFrame.write_parquet","title":"<code>write_parquet(file)</code>","text":"<p>Write dataframe to parquet file.</p> <p>Examples:</p> <p>Construct pandas and Polars DataFrames:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; def func(df):\n...     df = nw.from_native(df)\n...     df.write_parquet(\"foo.parquet\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n&gt;&gt;&gt; func(df_pl)\n</code></pre>"},{"location":"api-reference/dependencies/","title":"<code>narwhals.dependencies</code>","text":""},{"location":"api-reference/dependencies/#narwhals.dependencies.get_pandas","title":"<code>get_pandas()</code>","text":"<p>Get pandas module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_polars","title":"<code>get_polars()</code>","text":"<p>Get Polars module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_modin","title":"<code>get_modin()</code>","text":"<p>Get modin.pandas module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_cudf","title":"<code>get_cudf()</code>","text":"<p>Get cudf module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.get_pyarrow","title":"<code>get_pyarrow()</code>","text":"<p>Get pyarrow module (if already imported - else return None).</p>"},{"location":"api-reference/dependencies/#narwhals.dependencies.is_pandas_dataframe","title":"<code>is_pandas_dataframe(df)</code>","text":"<p>Check whether <code>df</code> is a pandas DataFrame without importing pandas.</p>"},{"location":"api-reference/dtypes/","title":"<code>narwhals.dtypes</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Int64","title":"<code>Int64</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Int32","title":"<code>Int32</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Int16","title":"<code>Int16</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Int8","title":"<code>Int8</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt64","title":"<code>UInt64</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt32","title":"<code>UInt32</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt16","title":"<code>UInt16</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.UInt8","title":"<code>UInt8</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Float64","title":"<code>Float64</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Float32","title":"<code>Float32</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Boolean","title":"<code>Boolean</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Categorical","title":"<code>Categorical</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Enum","title":"<code>Enum</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.String","title":"<code>String</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Datetime","title":"<code>Datetime</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Duration","title":"<code>Duration</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Object","title":"<code>Object</code>","text":""},{"location":"api-reference/dtypes/#narwhals.dtypes.Unknown","title":"<code>Unknown</code>","text":""},{"location":"api-reference/expr/","title":"<code>narwhals.Expr</code>","text":""},{"location":"api-reference/expr/#narwhals.Expr.abs","title":"<code>abs()</code>","text":"<p>Return absolute value of each element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, -2], \"b\": [-3, 4]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").abs())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  3\n1  2  4\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 3   \u2502\n\u2502 2   \u2506 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.alias","title":"<code>alias(name)</code>","text":"<p>Rename the expression.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select((nw.col(\"b\") + 10).alias(\"c\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    c\n0  14\n1  15\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 c   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 14  \u2502\n\u2502 15  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.all","title":"<code>all()</code>","text":"<p>Return whether all values in the column are <code>True</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").all())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a     b\n0  False  True\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b    \u2502\n\u2502 ---   \u2506 ---  \u2502\n\u2502 bool  \u2506 bool \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2506 true \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.any","title":"<code>any()</code>","text":"<p>Return whether any of the values in the column are <code>True</code></p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [True, False], \"b\": [True, True]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").any())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n      a     b\n0  True  True\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b    \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 bool \u2506 bool \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 true \u2506 true \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.arg_true","title":"<code>arg_true()</code>","text":"<p>Find elements where boolean expression is True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, None, None, 2]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").is_null().arg_true())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  1\n1  2\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cast","title":"<code>cast(dtype)</code>","text":"<p>Redefine an object's data type.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>Any</code> <p>Data type that the object will be cast into.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; from datetime import date\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\n...         nw.col(\"foo\").cast(nw.Float32), nw.col(\"bar\").cast(nw.UInt8)\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0  1.0    6\n1  2.0    7\n2  3.0    8\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 f32 \u2506 u8  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0 \u2506 6   \u2502\n\u2502 2.0 \u2506 7   \u2502\n\u2502 3.0 \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.count","title":"<code>count()</code>","text":"<p>Returns the number of non-null elements in the column.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [None, 4, 4]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [None, 4, 4]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().count())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  3  2\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 u32 \u2506 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3   \u2506 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.cum_sum","title":"<code>cum_sum()</code>","text":"<p>Return cumulative sum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").cum_sum())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a   b\n0   1   2\n1   2   6\n2   5  10\n3  10  16\n4  15  22\n&gt;&gt;&gt; func(df_pl)\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2   \u2502\n\u2502 2   \u2506 6   \u2502\n\u2502 5   \u2506 10  \u2502\n\u2502 10  \u2506 16  \u2502\n\u2502 15  \u2506 22  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.diff","title":"<code>diff()</code>","text":"<p>Returns the difference between each element and the previous one.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to calculate the diff and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>nw.col(\"a\").diff().fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(a_diff=nw.col(\"a\").diff())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a_diff\n0     NaN\n1     0.0\n2     2.0\n3     2.0\n4     0.0\n&gt;&gt;&gt; func(df_pl)\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_diff \u2502\n\u2502 ---    \u2502\n\u2502 i64    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null   \u2502\n\u2502 0      \u2502\n\u2502 2      \u2502\n\u2502 2      \u2502\n\u2502 0      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.drop_nulls","title":"<code>drop_nulls()</code>","text":"<p>Remove missing values.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [2.0, 4.0, float(\"nan\"), 3.0, None, 5.0]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [2.0, 4.0, float(\"nan\"), 3.0, None, 5.0]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").drop_nulls())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a\n0  2.0\n1  4.0\n3  3.0\n5  5.0\n&gt;&gt;&gt; func(df_pl)  # nan != null for polars\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2.0 \u2502\n\u2502 4.0 \u2502\n\u2502 NaN \u2502\n\u2502 3.0 \u2502\n\u2502 5.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.fill_null","title":"<code>fill_null(value)</code>","text":"<p>Fill null values with given value.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\"a\": [2, 4, None, 3, 5], \"b\": [2.0, 4.0, float(\"nan\"), 3.0, 5.0]}\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\"a\": [2, 4, None, 3, 5], \"b\": [2.0, 4.0, float(\"nan\"), 3.0, 5.0]}\n... )\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(nw.col(\"a\", \"b\").fill_null(0))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a    b\n0  2.0  2.0\n1  4.0  4.0\n2  0.0  0.0\n3  3.0  3.0\n4  5.0  5.0\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)  # nan != null for polars\nshape: (5, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 2.0 \u2502\n\u2502 4   \u2506 4.0 \u2502\n\u2502 0   \u2506 NaN \u2502\n\u2502 3   \u2506 3.0 \u2502\n\u2502 5   \u2506 5.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.filter","title":"<code>filter(*predicates)</code>","text":"<p>Filters elements based on a condition, returning a new expression.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [2, 3, 4, 5, 6, 7], \"b\": [10, 11, 12, 13, 14, 15]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [2, 3, 4, 5, 6, 7], \"b\": [10, 11, 12, 13, 14, 15]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\n...         nw.col(\"a\").filter(nw.col(\"a\") &gt; 4),\n...         nw.col(\"b\").filter(nw.col(\"b\") &lt; 13),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a   b\n3  5  10\n4  6  11\n5  7  12\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 5   \u2506 10  \u2502\n\u2502 6   \u2506 11  \u2502\n\u2502 7   \u2506 12  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.gather_every","title":"<code>gather_every(n, offset=0)</code>","text":"<p>Take every nth value in the Series and return as new Series.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Gather every n-th row.</p> required <code>offset</code> <code>int</code> <p>Starting index.</p> <code>0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 4], \"b\": [5, 6, 7, 8]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function in which gather every 2 rows, starting from a offset of 1:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").gather_every(n=2, offset=1))\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n1  2\n3  4\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2502\n\u2502 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.head","title":"<code>head(n=10)</code>","text":"<p>Get the first <code>n</code> rows.</p> <p>Arguments     n : int         Number of rows to return.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": list(range(10))}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the first 3 rows:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").head(3))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  0\n1  1\n2  2\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2502\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_between","title":"<code>is_between(lower_bound, upper_bound, closed='both')</code>","text":"<p>Check if this expression is between the given lower and upper bounds.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Any</code> <p>Lower bound value.</p> required <code>upper_bound</code> <code>Any</code> <p>Upper bound value.</p> required <code>closed</code> <code>str</code> <p>Define which sides of the interval are closed (inclusive).</p> <code>'both'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3, 4, 5]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3, 4, 5]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").is_between(2, 4, \"right\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a\n0  False\n1  False\n2   True\n3   True\n4  False\n&gt;&gt;&gt; func(df_pl)\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2502\n\u2502 ---   \u2502\n\u2502 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2502\n\u2502 false \u2502\n\u2502 true  \u2502\n\u2502 true  \u2502\n\u2502 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_duplicated","title":"<code>is_duplicated()</code>","text":"<p>Return a boolean mask indicating duplicated values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().is_duplicated())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a      b\n0   True   True\n1  False   True\n2  False  False\n3   True  False\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b     \u2502\n\u2502 ---   \u2506 ---   \u2502\n\u2502 bool  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 true  \u2506 true  \u2502\n\u2502 false \u2506 true  \u2502\n\u2502 false \u2506 false \u2502\n\u2502 true  \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_first_distinct","title":"<code>is_first_distinct()</code>","text":"<p>Return a boolean mask indicating the first occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().is_first_distinct())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a      b\n0   True   True\n1   True  False\n2   True   True\n3  False   True\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b     \u2502\n\u2502 ---   \u2506 ---   \u2502\n\u2502 bool  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 true  \u2506 true  \u2502\n\u2502 true  \u2506 false \u2502\n\u2502 true  \u2506 true  \u2502\n\u2502 false \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_in","title":"<code>is_in(other)</code>","text":"<p>Check if elements of this expression are present in the other iterable.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>iterable</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 9, 10]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 9, 10]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(b=nw.col(\"a\").is_in([1, 2]))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a      b\n0   1   True\n1   2   True\n2   9  False\n3  10  False\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b     \u2502\n\u2502 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 true  \u2502\n\u2502 2   \u2506 true  \u2502\n\u2502 9   \u2506 false \u2502\n\u2502 10  \u2506 false \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_last_distinct","title":"<code>is_last_distinct()</code>","text":"<p>Return a boolean mask indicating the last occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().is_last_distinct())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a      b\n0  False  False\n1   True   True\n2   True   True\n3   True   True\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b     \u2502\n\u2502 ---   \u2506 ---   \u2502\n\u2502 bool  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2506 false \u2502\n\u2502 true  \u2506 true  \u2502\n\u2502 true  \u2506 true  \u2502\n\u2502 true  \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_null","title":"<code>is_null()</code>","text":"<p>Returns a boolean Series indicating which values are null.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\"a\": [2, 4, None, 3, 5], \"b\": [2.0, 4.0, float(\"nan\"), 3.0, 5.0]}\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\"a\": [2, 4, None, 3, 5], \"b\": [2.0, 4.0, float(\"nan\"), 3.0, 5.0]}\n... )\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         a_is_null=nw.col(\"a\").is_null(), b_is_null=nw.col(\"b\").is_null()\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a    b  a_is_null  b_is_null\n0  2.0  2.0      False      False\n1  4.0  4.0      False      False\n2  NaN  NaN       True       True\n3  3.0  3.0      False      False\n4  5.0  5.0      False      False\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)  # nan != null for polars\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 a_is_null \u2506 b_is_null \u2502\n\u2502 ---  \u2506 --- \u2506 ---       \u2506 ---       \u2502\n\u2502 i64  \u2506 f64 \u2506 bool      \u2506 bool      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2    \u2506 2.0 \u2506 false     \u2506 false     \u2502\n\u2502 4    \u2506 4.0 \u2506 false     \u2506 false     \u2502\n\u2502 null \u2506 NaN \u2506 true      \u2506 false     \u2502\n\u2502 3    \u2506 3.0 \u2506 false     \u2506 false     \u2502\n\u2502 5    \u2506 5.0 \u2506 false     \u2506 false     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.is_unique","title":"<code>is_unique()</code>","text":"<p>Return a boolean mask indicating unique values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 1], \"b\": [\"a\", \"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().is_unique())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a      b\n0  False  False\n1   True  False\n2   True   True\n3  False   True\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b     \u2502\n\u2502 ---   \u2506 ---   \u2502\n\u2502 bool  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2506 false \u2502\n\u2502 true  \u2506 false \u2502\n\u2502 true  \u2506 true  \u2502\n\u2502 false \u2506 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.len","title":"<code>len()</code>","text":"<p>Return the number of elements in the column.</p> <p>Null values count towards the total.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [\"x\", \"y\", \"z\"], \"b\": [1, 2, 1]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that computes the len over different values of \"b\" column:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\n...         nw.col(\"a\").filter(nw.col(\"b\") == 1).len().alias(\"a1\"),\n...         nw.col(\"a\").filter(nw.col(\"b\") == 2).len().alias(\"a2\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a1  a2\n0    2   1\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a1  \u2506 a2  \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 u32 \u2506 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.max","title":"<code>max()</code>","text":"<p>Returns the maximum value(s) from a column(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [10, 20], \"b\": [50, 100]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [10, 20], \"b\": [50, 100]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.max(\"a\", \"b\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a    b\n0  20  100\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 20  \u2506 100 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.mean","title":"<code>mean()</code>","text":"<p>Get mean value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [-1, 0, 1], \"b\": [2, 4, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [-1, 0, 1], \"b\": [2, 4, 6]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").mean())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a    b\n0  0.0  4.0\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 f64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0.0 \u2506 4.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.min","title":"<code>min()</code>","text":"<p>Returns the minimum value(s) from a column(s).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 3]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [4, 3]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.min(\"a\", \"b\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  3\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.null_count","title":"<code>null_count()</code>","text":"<p>Count null values.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, None, 1], \"b\": [\"a\", None, \"b\", None]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all().null_count())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  2\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 u32 \u2506 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.n_unique","title":"<code>n_unique()</code>","text":"<p>Returns count of unique values</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3, 4, 5], \"b\": [1, 1, 3, 3, 5]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3, 4, 5], \"b\": [1, 1, 3, 3, 5]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").n_unique())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  5  3\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 u32 \u2506 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 5   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.over","title":"<code>over(*keys)</code>","text":"<p>Compute expressions over the given groups.</p> <p>Parameters:</p> Name Type Description Default <code>keys</code> <code>str | Iterable[str]</code> <p>Names of columns to compute window expression over.   Must be names of columns, as opposed to expressions -   so, this is a bit less flexible than Polars' <code>Expr.over</code>.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [1, 1, 2]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(a_min_per_group=nw.col(\"a\").min().over(\"b\"))\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b  a_min_per_group\n0  1  1                1\n1  2  1                1\n2  3  2                3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 a_min_per_group \u2502\n\u2502 --- \u2506 --- \u2506 ---             \u2502\n\u2502 i64 \u2506 i64 \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 1   \u2506 1               \u2502\n\u2502 2   \u2506 1   \u2506 1               \u2502\n\u2502 3   \u2506 2   \u2506 3               \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.quantile","title":"<code>quantile(quantile, interpolation)</code>","text":"<p>Get quantile value.</p> Note <p>pandas and Polars may have implementation differences for a given interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <p>float Quantile between 0.0 and 1.0.</p> required <code>interpolation</code> <p>{'nearest', 'higher', 'lower', 'midpoint', 'linear'} Interpolation method.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": list(range(50)), \"b\": list(range(50, 100))}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").quantile(0.5, interpolation=\"linear\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a   b\n0  24.5  74.5\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b    \u2502\n\u2502 ---  \u2506 ---  \u2502\n\u2502 f64  \u2506 f64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 24.5 \u2506 74.5 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.round","title":"<code>round(decimals=0)</code>","text":"<p>Round underlying floating point data by <code>decimals</code> digits.</p> <p>Parameters:</p> Name Type Description Default <code>decimals</code> <code>int</code> <p>Number of decimals to round by.</p> <code>0</code> Notes <p>For values exactly halfway between rounded decimal values pandas and Polars behave differently.</p> <p>pandas rounds to the nearest even value (e.g. -0.5 and 0.5 round to 0.0, 1.5 and 2.5 round to 2.0, 3.5 and 4.5 to 4.0, etc..).</p> <p>Polars rounds away from 0 (e.g. -0.5 to -1.0, 0.5 to 1.0, 1.5 to 2.0, 2.5 to 3.0, etc..).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1.12345, 2.56789, 3.901234]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that rounds to the first decimal:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").round(1))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a\n0  1.1\n1  2.6\n2  3.9\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.1 \u2502\n\u2502 2.6 \u2502\n\u2502 3.9 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.sample","title":"<code>sample(n=None, fraction=None, *, with_replacement=False)</code>","text":"<p>Sample randomly from this expression.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of items to return. Cannot be used with fraction.</p> <code>None</code> <code>fraction</code> <code>float | None</code> <p>Fraction of items to return. Cannot be used with n.</p> <code>None</code> <code>with_replacement</code> <code>bool</code> <p>Allow values to be sampled more than once.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").sample(fraction=1.0, with_replacement=True))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n2  3\n0  1\n2  3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.shift","title":"<code>shift(n)</code>","text":"<p>Shift values by <code>n</code> positions.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to shift and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>nw.col(\"a\").shift(1).fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 1, 3, 5, 5]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(a_shift=nw.col(\"a\").shift(n=1))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a_shift\n0      NaN\n1      1.0\n2      1.0\n3      3.0\n4      5.0\n&gt;&gt;&gt; func(df_pl)\nshape: (5, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_shift \u2502\n\u2502 ---     \u2502\n\u2502 i64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null    \u2502\n\u2502 1       \u2502\n\u2502 1       \u2502\n\u2502 3       \u2502\n\u2502 5       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.sort","title":"<code>sort(*, descending=False, nulls_last=False)</code>","text":"<p>Sort this column. Place null values first.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Sort in descending order.</p> <code>False</code> <code>nulls_last</code> <code>bool</code> <p>Place null values last instead of first.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [5, None, 1, 2]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [5, None, 1, 2]})\n</code></pre> <p>Let's define dataframe-agnostic functions:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").sort())\n</code></pre> <pre><code>&gt;&gt;&gt; def func_descend(df):\n...     df = nw.from_native(df)\n...     df = df.select(nw.col(\"a\").sort(descending=True))\n...     return nw.to_native(df)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a\n1  NaN\n2  1.0\n3  2.0\n0  5.0\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2502\n\u2502 ---  \u2502\n\u2502 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null \u2502\n\u2502 1    \u2502\n\u2502 2    \u2502\n\u2502 5    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>&gt;&gt;&gt; func_descend(df_pd)\n     a\n1  NaN\n0  5.0\n3  2.0\n2  1.0\n&gt;&gt;&gt; func_descend(df_pl)\nshape: (4, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2502\n\u2502 ---  \u2502\n\u2502 i64  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 null \u2502\n\u2502 5    \u2502\n\u2502 2    \u2502\n\u2502 1    \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.std","title":"<code>std(*, ddof=1)</code>","text":"<p>Get standard deviation.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is N - ddof,      where N represents the number of elements. By default ddof is 1.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [20, 25, 60], \"b\": [1.5, 1, -1.4]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [20, 25, 60], \"b\": [1.5, 1, -1.4]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").std(ddof=0))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n          a         b\n0  17.79513  1.265789\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a        \u2506 b        \u2502\n\u2502 ---      \u2506 ---      \u2502\n\u2502 f64      \u2506 f64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 17.79513 \u2506 1.265789 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.sum","title":"<code>sum()</code>","text":"<p>Return the sum value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [5, 10], \"b\": [50, 100]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [5, 10], \"b\": [50, 100]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").sum())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a    b\n0  15  150\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 15  \u2506 150 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.tail","title":"<code>tail(n=10)</code>","text":"<p>Get the last <code>n</code> rows.</p> <p>Arguments     n : int         Number of rows to return.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": list(range(10))}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the last 3 rows:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").tail(3))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a\n7  7\n8  8\n9  9\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 7   \u2502\n\u2502 8   \u2502\n\u2502 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr/#narwhals.Expr.unique","title":"<code>unique()</code>","text":"<p>Return unique values</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 1, 3, 5, 5], \"b\": [2, 4, 4, 6, 6]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\", \"b\").unique())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  2\n1  3  4\n2  5  6\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2   \u2502\n\u2502 3   \u2506 4   \u2502\n\u2502 5   \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_cat/","title":"<code>narwhals.Expr.cat</code>","text":""},{"location":"api-reference/expr_cat/#narwhals.expr.ExprCatNamespace.get_categories","title":"<code>get_categories()</code>","text":"<p>Get unique categories from column.</p> <p>Examples:</p> <p>Let's create some dataframes:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"fruits\": [\"apple\", \"mango\", \"mango\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data, dtype=\"category\")\n&gt;&gt;&gt; df_pl = pl.DataFrame(data, schema={\"fruits\": pl.Categorical})\n</code></pre> <p>We define a dataframe-agnostic function to get unique categories from column 'fruits':</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"fruits\").cat.get_categories())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n  fruits\n0  apple\n1  mango\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fruits \u2502\n\u2502 ---    \u2502\n\u2502 str    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 apple  \u2502\n\u2502 mango  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/","title":"<code>narwhals.Expr.dt</code>","text":""},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.year","title":"<code>year()</code>","text":"<p>Extract year from underlying DateTime representation.</p> <p>Returns the year number in the calendar date.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 6, 1),\n...         datetime(2024, 12, 13),\n...         datetime(2065, 1, 1),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(nw.col(\"datetime\").dt.year().alias(\"year\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    datetime  year\n0 1978-06-01  1978\n1 2024-12-13  2024\n2 2065-01-01  2065\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 year \u2502\n\u2502 ---                 \u2506 ---  \u2502\n\u2502 datetime[\u03bcs]        \u2506 i32  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-06-01 00:00:00 \u2506 1978 \u2502\n\u2502 2024-12-13 00:00:00 \u2506 2024 \u2502\n\u2502 2065-01-01 00:00:00 \u2506 2065 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.month","title":"<code>month()</code>","text":"<p>Extract month from underlying DateTime representation.</p> <p>Returns the month number starting from 1. The return value ranges from 1 to 12.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 6, 1),\n...         datetime(2024, 12, 13),\n...         datetime(2065, 1, 1),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.year().alias(\"year\"),\n...         nw.col(\"datetime\").dt.month().alias(\"month\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    datetime  year  month\n0 1978-06-01  1978      6\n1 2024-12-13  2024     12\n2 2065-01-01  2065      1\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 year \u2506 month \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---   \u2502\n\u2502 datetime[\u03bcs]        \u2506 i32  \u2506 i8    \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-06-01 00:00:00 \u2506 1978 \u2506 6     \u2502\n\u2502 2024-12-13 00:00:00 \u2506 2024 \u2506 12    \u2502\n\u2502 2065-01-01 00:00:00 \u2506 2065 \u2506 1     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.day","title":"<code>day()</code>","text":"<p>Extract day from underlying DateTime representation.</p> <p>Returns the day of month starting from 1. The return value ranges from 1 to 31. (The last day of month differs by months.)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 6, 1),\n...         datetime(2024, 12, 13),\n...         datetime(2065, 1, 1),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.year().alias(\"year\"),\n...         nw.col(\"datetime\").dt.month().alias(\"month\"),\n...         nw.col(\"datetime\").dt.day().alias(\"day\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    datetime  year  month  day\n0 1978-06-01  1978      6    1\n1 2024-12-13  2024     12   13\n2 2065-01-01  2065      1    1\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 year \u2506 month \u2506 day \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---   \u2506 --- \u2502\n\u2502 datetime[\u03bcs]        \u2506 i32  \u2506 i8    \u2506 i8  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-06-01 00:00:00 \u2506 1978 \u2506 6     \u2506 1   \u2502\n\u2502 2024-12-13 00:00:00 \u2506 2024 \u2506 12    \u2506 13  \u2502\n\u2502 2065-01-01 00:00:00 \u2506 2065 \u2506 1     \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.ordinal_day","title":"<code>ordinal_day()</code>","text":"<p>Get ordinal day.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [datetime(2020, 1, 1), datetime(2020, 8, 3)]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(a_ordinal_day=nw.col(\"a\").dt.ordinal_day())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n           a  a_ordinal_day\n0 2020-01-01              1\n1 2020-08-03            216\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a                   \u2506 a_ordinal_day \u2502\n\u2502 ---                 \u2506 ---           \u2502\n\u2502 datetime[\u03bcs]        \u2506 i16           \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 00:00:00 \u2506 1             \u2502\n\u2502 2020-08-03 00:00:00 \u2506 216           \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.hour","title":"<code>hour()</code>","text":"<p>Extract hour from underlying DateTime representation.</p> <p>Returns the hour number from 0 to 23.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1),\n...         datetime(2024, 10, 13, 5),\n...         datetime(2065, 1, 1, 10),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(nw.col(\"datetime\").dt.hour().alias(\"hour\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n             datetime  hour\n0 1978-01-01 01:00:00     1\n1 2024-10-13 05:00:00     5\n2 2065-01-01 10:00:00    10\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 hour \u2502\n\u2502 ---                 \u2506 ---  \u2502\n\u2502 datetime[\u03bcs]        \u2506 i8   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:00:00 \u2506 1    \u2502\n\u2502 2024-10-13 05:00:00 \u2506 5    \u2502\n\u2502 2065-01-01 10:00:00 \u2506 10   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.minute","title":"<code>minute()</code>","text":"<p>Extract minutes from underlying DateTime representation.</p> <p>Returns the minute number from 0 to 59.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1, 1),\n...         datetime(2024, 10, 13, 5, 30),\n...         datetime(2065, 1, 1, 10, 20),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.hour().alias(\"hour\"),\n...         nw.col(\"datetime\").dt.minute().alias(\"minute\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n             datetime  hour  minute\n0 1978-01-01 01:01:00     1       1\n1 2024-10-13 05:30:00     5      30\n2 2065-01-01 10:20:00    10      20\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 hour \u2506 minute \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---    \u2502\n\u2502 datetime[\u03bcs]        \u2506 i8   \u2506 i8     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:01:00 \u2506 1    \u2506 1      \u2502\n\u2502 2024-10-13 05:30:00 \u2506 5    \u2506 30     \u2502\n\u2502 2065-01-01 10:20:00 \u2506 10   \u2506 20     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.second","title":"<code>second()</code>","text":"<p>Extract seconds from underlying DateTime representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1, 1, 1),\n...         datetime(2024, 10, 13, 5, 30, 14),\n...         datetime(2065, 1, 1, 10, 20, 30),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.hour().alias(\"hour\"),\n...         nw.col(\"datetime\").dt.minute().alias(\"minute\"),\n...         nw.col(\"datetime\").dt.second().alias(\"second\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n             datetime  hour  minute  second\n0 1978-01-01 01:01:01     1       1       1\n1 2024-10-13 05:30:14     5      30      14\n2 2065-01-01 10:20:30    10      20      30\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime            \u2506 hour \u2506 minute \u2506 second \u2502\n\u2502 ---                 \u2506 ---  \u2506 ---    \u2506 ---    \u2502\n\u2502 datetime[\u03bcs]        \u2506 i8   \u2506 i8     \u2506 i8     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:01:01 \u2506 1    \u2506 1      \u2506 1      \u2502\n\u2502 2024-10-13 05:30:14 \u2506 5    \u2506 30     \u2506 14     \u2502\n\u2502 2065-01-01 10:20:30 \u2506 10   \u2506 20     \u2506 30     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.millisecond","title":"<code>millisecond()</code>","text":"<p>Extract milliseconds from underlying DateTime representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1, 1, 1, 0),\n...         datetime(2024, 10, 13, 5, 30, 14, 505000),\n...         datetime(2065, 1, 1, 10, 20, 30, 67000),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.hour().alias(\"hour\"),\n...         nw.col(\"datetime\").dt.minute().alias(\"minute\"),\n...         nw.col(\"datetime\").dt.second().alias(\"second\"),\n...         nw.col(\"datetime\").dt.millisecond().alias(\"millisecond\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                 datetime  hour  minute  second  millisecond\n0 1978-01-01 01:01:01.000     1       1       1            0\n1 2024-10-13 05:30:14.505     5      30      14          505\n2 2065-01-01 10:20:30.067    10      20      30           67\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime                \u2506 hour \u2506 minute \u2506 second \u2506 millisecond \u2502\n\u2502 ---                     \u2506 ---  \u2506 ---    \u2506 ---    \u2506 ---         \u2502\n\u2502 datetime[\u03bcs]            \u2506 i8   \u2506 i8     \u2506 i8     \u2506 i32         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:01:01     \u2506 1    \u2506 1      \u2506 1      \u2506 0           \u2502\n\u2502 2024-10-13 05:30:14.505 \u2506 5    \u2506 30     \u2506 14     \u2506 505         \u2502\n\u2502 2065-01-01 10:20:30.067 \u2506 10   \u2506 20     \u2506 30     \u2506 67          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.microsecond","title":"<code>microsecond()</code>","text":"<p>Extract microseconds from underlying DateTime representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1, 1, 1, 0),\n...         datetime(2024, 10, 13, 5, 30, 14, 505000),\n...         datetime(2065, 1, 1, 10, 20, 30, 67000),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.hour().alias(\"hour\"),\n...         nw.col(\"datetime\").dt.minute().alias(\"minute\"),\n...         nw.col(\"datetime\").dt.second().alias(\"second\"),\n...         nw.col(\"datetime\").dt.microsecond().alias(\"microsecond\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                 datetime  hour  minute  second  microsecond\n0 1978-01-01 01:01:01.000     1       1       1            0\n1 2024-10-13 05:30:14.505     5      30      14       505000\n2 2065-01-01 10:20:30.067    10      20      30        67000\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime                \u2506 hour \u2506 minute \u2506 second \u2506 microsecond \u2502\n\u2502 ---                     \u2506 ---  \u2506 ---    \u2506 ---    \u2506 ---         \u2502\n\u2502 datetime[\u03bcs]            \u2506 i8   \u2506 i8     \u2506 i8     \u2506 i32         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:01:01     \u2506 1    \u2506 1      \u2506 1      \u2506 0           \u2502\n\u2502 2024-10-13 05:30:14.505 \u2506 5    \u2506 30     \u2506 14     \u2506 505000      \u2502\n\u2502 2065-01-01 10:20:30.067 \u2506 10   \u2506 20     \u2506 30     \u2506 67000       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.nanosecond","title":"<code>nanosecond()</code>","text":"<p>Extract Nanoseconds from underlying DateTime representation</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"datetime\": [\n...         datetime(1978, 1, 1, 1, 1, 1, 0),\n...         datetime(2024, 10, 13, 5, 30, 14, 500000),\n...         datetime(2065, 1, 1, 10, 20, 30, 60000),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         nw.col(\"datetime\").dt.hour().alias(\"hour\"),\n...         nw.col(\"datetime\").dt.minute().alias(\"minute\"),\n...         nw.col(\"datetime\").dt.second().alias(\"second\"),\n...         nw.col(\"datetime\").dt.nanosecond().alias(\"nanosecond\"),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                 datetime  hour  minute  second  nanosecond\n0 1978-01-01 01:01:01.000     1       1       1           0\n1 2024-10-13 05:30:14.500     5      30      14   500000000\n2 2065-01-01 10:20:30.060    10      20      30    60000000\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 5)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 datetime                \u2506 hour \u2506 minute \u2506 second \u2506 nanosecond \u2502\n\u2502 ---                     \u2506 ---  \u2506 ---    \u2506 ---    \u2506 ---        \u2502\n\u2502 datetime[\u03bcs]            \u2506 i8   \u2506 i8     \u2506 i8     \u2506 i32        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1978-01-01 01:01:01     \u2506 1    \u2506 1      \u2506 1      \u2506 0          \u2502\n\u2502 2024-10-13 05:30:14.500 \u2506 5    \u2506 30     \u2506 14     \u2506 500000000  \u2502\n\u2502 2065-01-01 10:20:30.060 \u2506 10   \u2506 20     \u2506 30     \u2506 60000000   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_minutes","title":"<code>total_minutes()</code>","text":"<p>Get total minutes.</p> Notes <p>The function outputs the total minutes in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [timedelta(minutes=10), timedelta(minutes=20, seconds=40)]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(a_total_minutes=nw.col(\"a\").dt.total_minutes())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                a  a_total_minutes\n0 0 days 00:10:00               10\n1 0 days 00:20:40               20\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_minutes \u2502\n\u2502 ---          \u2506 ---             \u2502\n\u2502 duration[\u03bcs] \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10m          \u2506 10              \u2502\n\u2502 20m 40s      \u2506 20              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_seconds","title":"<code>total_seconds()</code>","text":"<p>Get total seconds.</p> Notes <p>The function outputs the total seconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [timedelta(seconds=10), timedelta(seconds=20, milliseconds=40)]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(a_total_seconds=nw.col(\"a\").dt.total_seconds())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                       a  a_total_seconds\n0        0 days 00:00:10               10\n1 0 days 00:00:20.040000               20\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_seconds \u2502\n\u2502 ---          \u2506 ---             \u2502\n\u2502 duration[\u03bcs] \u2506 i64             \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10s          \u2506 10              \u2502\n\u2502 20s 40ms     \u2506 20              \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_milliseconds","title":"<code>total_milliseconds()</code>","text":"<p>Get total milliseconds.</p> Notes <p>The function outputs the total milliseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"a\": [\n...         timedelta(milliseconds=10),\n...         timedelta(milliseconds=20, microseconds=40),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         a_total_milliseconds=nw.col(\"a\").dt.total_milliseconds()\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                       a  a_total_milliseconds\n0 0 days 00:00:00.010000                    10\n1 0 days 00:00:00.020040                    20\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_milliseconds \u2502\n\u2502 ---          \u2506 ---                  \u2502\n\u2502 duration[\u03bcs] \u2506 i64                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10ms         \u2506 10                   \u2502\n\u2502 20040\u00b5s      \u2506 20                   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_microseconds","title":"<code>total_microseconds()</code>","text":"<p>Get total microseconds.</p> Notes <p>The function outputs the total microseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"a\": [\n...         timedelta(microseconds=10),\n...         timedelta(milliseconds=1, microseconds=200),\n...     ]\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         a_total_microseconds=nw.col(\"a\").dt.total_microseconds()\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                       a  a_total_microseconds\n0 0 days 00:00:00.000010                    10\n1 0 days 00:00:00.001200                  1200\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a            \u2506 a_total_microseconds \u2502\n\u2502 ---          \u2506 ---                  \u2502\n\u2502 duration[\u03bcs] \u2506 i64                  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 10\u00b5s         \u2506 10                   \u2502\n\u2502 1200\u00b5s       \u2506 1200                 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.total_nanoseconds","title":"<code>total_nanoseconds()</code>","text":"<p>Get total nanoseconds.</p> Notes <p>The function outputs the total nanoseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> and <code>cast</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\"2024-01-01 00:00:00.000000001\", \"2024-01-01 00:00:00.000000002\"]\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": pd.to_datetime(data)})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": data}).with_columns(\n...     pl.col(\"a\").str.to_datetime(time_unit=\"ns\")\n... )\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         a_diff_total_nanoseconds=nw.col(\"a\").diff().dt.total_nanoseconds()\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                              a  a_diff_total_nanoseconds\n0 2024-01-01 00:00:00.000000001                       NaN\n1 2024-01-01 00:00:00.000000002                       1.0\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a                             \u2506 a_diff_total_nanoseconds \u2502\n\u2502 ---                           \u2506 ---                      \u2502\n\u2502 datetime[ns]                  \u2506 i64                      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2024-01-01 00:00:00.000000001 \u2506 null                     \u2502\n\u2502 2024-01-01 00:00:00.000000002 \u2506 1                        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_dt/#narwhals.expr.ExprDateTimeNamespace.to_string","title":"<code>to_string(format)</code>","text":"<p>Convert a Date/Time/Datetime column into a String column with the given format.</p> Notes <p>Unfortunately, different libraries interpret format directives a bit differently.</p> <ul> <li>Chrono, the library used by Polars, uses <code>\"%.f\"</code> for fractional seconds,   whereas pandas and Python stdlib use <code>\".%f\"</code>.</li> <li>PyArrow interprets <code>\"%S\"</code> as \"seconds, including fractional seconds\"   whereas most other tools interpret it as \"just seconds, as 2 digits\".</li> </ul> <p>Therefore, we make the following adjustments:</p> <ul> <li>for pandas-like libraries, we replace <code>\"%S.%f\"</code> with <code>\"%S%.f\"</code>.</li> <li>for PyArrow, we replace <code>\"%S.%f\"</code> with <code>\"%S\"</code>.</li> </ul> <p>Workarounds like these don't make us happy, and we try to avoid them as much as possible, but here we feel like it's the best compromise.</p> <p>If you just want to format a date/datetime Series as a local datetime string, and have it work as consistently as possible across libraries, we suggest using:</p> <ul> <li><code>\"%Y-%m-%dT%H:%M:%S%.f\"</code> for datetimes</li> <li><code>\"%Y-%m-%d\"</code> for dates</li> </ul> <p>though note that, even then, different tools may return a different number of trailing zeros. Nonetheless, this is probably consistent enough for most applications.</p> <p>If you have an application where this is not enough, please open an issue and let us know.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     datetime(2020, 3, 1),\n...     datetime(2020, 4, 1),\n...     datetime(2020, 5, 1),\n... ]\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": data})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": data})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").dt.to_string(\"%Y/%m/%d %H:%M:%S\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                     a\n0  2020/03/01 00:00:00\n1  2020/04/01 00:00:00\n2  2020/05/01 00:00:00\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a                   \u2502\n\u2502 ---                 \u2502\n\u2502 str                 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020/03/01 00:00:00 \u2502\n\u2502 2020/04/01 00:00:00 \u2502\n\u2502 2020/05/01 00:00:00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_name/","title":"<code>narwhals.Expr.name</code>","text":""},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.keep","title":"<code>keep()</code>","text":"<p>Keep the original root name of the expression.</p> Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"foo\": [1, 2], \"BAR\": [4, 5]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"foo\").alias(\"alias_for_foo\").name.keep())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd).columns\nIndex(['foo'], dtype='object')\n&gt;&gt;&gt; func(df_pl).columns\n['foo']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.map","title":"<code>map(function)</code>","text":"<p>Rename the output of an expression by mapping a function over the root name.</p> <p>Parameters:</p> Name Type Description Default <code>function</code> <code>Callable[[str], str]</code> <p>Function that maps a root name to a new name.</p> required Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"foo\": [1, 2], \"BAR\": [4, 5]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; renaming_func = lambda s: s[::-1]  # reverse column name\n&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"foo\", \"BAR\").name.map(renaming_func))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd).columns\nIndex(['oof', 'RAB'], dtype='object')\n&gt;&gt;&gt; func(df_pl).columns\n['oof', 'RAB']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.prefix","title":"<code>prefix(prefix)</code>","text":"<p>Add a prefix to the root column name of the expression.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>Prefix to add to the root column name.</p> required Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"foo\": [1, 2], \"BAR\": [4, 5]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def add_colname_prefix(df, prefix):\n...     return df.select(nw.col(\"foo\", \"BAR\").name.prefix(prefix))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; add_colname_prefix(df_pd, \"with_prefix_\").columns\nIndex(['with_prefix_foo', 'with_prefix_BAR'], dtype='object')\n</code></pre> <pre><code>&gt;&gt;&gt; add_colname_prefix(df_pl, \"with_prefix_\").columns\n['with_prefix_foo', 'with_prefix_BAR']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.suffix","title":"<code>suffix(suffix)</code>","text":"<p>Add a suffix to the root column name of the expression.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>Suffix to add to the root column name.</p> required Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"foo\": [1, 2], \"BAR\": [4, 5]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def add_colname_suffix(df, suffix):\n...     return df.select(nw.col(\"foo\", \"BAR\").name.suffix(suffix))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; add_colname_suffix(df_pd, \"_with_suffix\").columns\nIndex(['foo_with_suffix', 'BAR_with_suffix'], dtype='object')\n&gt;&gt;&gt; add_colname_suffix(df_pl, \"_with_suffix\").columns\n['foo_with_suffix', 'BAR_with_suffix']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.to_lowercase","title":"<code>to_lowercase()</code>","text":"<p>Make the root column name lowercase.</p> Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"foo\": [1, 2], \"BAR\": [4, 5]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def to_lower(df):\n...     return df.select(nw.col(\"foo\", \"BAR\").name.to_lowercase())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; to_lower(df_pd).columns\nIndex(['foo', 'bar'], dtype='object')\n&gt;&gt;&gt; to_lower(df_pl).columns\n['foo', 'bar']\n</code></pre>"},{"location":"api-reference/expr_name/#narwhals.expr.ExprNameNamespace.to_uppercase","title":"<code>to_uppercase()</code>","text":"<p>Make the root column name uppercase.</p> Notes <p>This will undo any previous renaming operations on the expression. Due to implementation constraints, this method can only be called as the last expression in a chain. Only one name operation per expression will work.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"foo\": [1, 2], \"BAR\": [4, 5]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def to_upper(df):\n...     return df.select(nw.col(\"foo\", \"BAR\").name.to_uppercase())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; to_upper(df_pd).columns\nIndex(['FOO', 'BAR'], dtype='object')\n&gt;&gt;&gt; to_upper(df_pl).columns\n['FOO', 'BAR']\n</code></pre>"},{"location":"api-reference/expr_str/","title":"<code>narwhals.Expr.str</code>","text":""},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.contains","title":"<code>contains(pattern, *, literal=False)</code>","text":"<p>Check if string contains a substring that matches a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A Character sequence or valid regular expression pattern.</p> required <code>literal</code> <code>bool</code> <p>If True, treats the pattern as a literal string.      If False, assumes the pattern is a regular expression.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"pets\": [\"cat\", \"dog\", \"rabbit and parrot\", \"dove\", None]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(\n...         default_match=nw.col(\"pets\").str.contains(\"parrot|Dove\"),\n...         case_insensitive_match=nw.col(\"pets\").str.contains(\"(?i)parrot|Dove\"),\n...         literal_match=nw.col(\"pets\").str.contains(\n...             \"parrot|Dove\", literal=True\n...         ),\n...     )\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n                pets default_match case_insensitive_match literal_match\n0                cat         False                  False         False\n1                dog         False                  False         False\n2  rabbit and parrot          True                   True         False\n3               dove         False                   True         False\n4               None          None                   None          None\n&gt;&gt;&gt; func(df_pl)\nshape: (5, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 pets              \u2506 default_match \u2506 case_insensitive_match \u2506 literal_match \u2502\n\u2502 ---               \u2506 ---           \u2506 ---                    \u2506 ---           \u2502\n\u2502 str               \u2506 bool          \u2506 bool                   \u2506 bool          \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 cat               \u2506 false         \u2506 false                  \u2506 false         \u2502\n\u2502 dog               \u2506 false         \u2506 false                  \u2506 false         \u2502\n\u2502 rabbit and parrot \u2506 true          \u2506 true                   \u2506 false         \u2502\n\u2502 dove              \u2506 false         \u2506 true                   \u2506 false         \u2502\n\u2502 null              \u2506 null          \u2506 null                   \u2506 null          \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.ends_with","title":"<code>ends_with(suffix)</code>","text":"<p>Check if string values end with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>suffix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"fruits\": [\"apple\", \"mango\", None]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(has_suffix=nw.col(\"fruits\").str.ends_with(\"ngo\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n  fruits has_suffix\n0  apple      False\n1  mango       True\n2   None       None\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fruits \u2506 has_suffix \u2502\n\u2502 ---    \u2506 ---        \u2502\n\u2502 str    \u2506 bool       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 apple  \u2506 false      \u2502\n\u2502 mango  \u2506 true       \u2502\n\u2502 null   \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.head","title":"<code>head(n=5)</code>","text":"<p>Take the first n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is not supported.</p> <code>5</code> Notes <p>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"lyrics\": [\"Atatata\", \"taata\", \"taatatata\", \"zukkyun\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(lyrics_head=nw.col(\"lyrics\").str.head())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n      lyrics lyrics_head\n0    Atatata       Atata\n1      taata       taata\n2  taatatata       taata\n3    zukkyun       zukky\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 lyrics    \u2506 lyrics_head \u2502\n\u2502 ---       \u2506 ---         \u2502\n\u2502 str       \u2506 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Atatata   \u2506 Atata       \u2502\n\u2502 taata     \u2506 taata       \u2502\n\u2502 taatatata \u2506 taata       \u2502\n\u2502 zukkyun   \u2506 zukky       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.slice","title":"<code>slice(offset, length=None)</code>","text":"<p>Create subslices of the string values of an expression.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Start index. Negative indexing is supported.</p> required <code>length</code> <code>int | None</code> <p>Length of the slice. If set to <code>None</code> (default), the slice is taken to the end of the string.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"s\": [\"pear\", None, \"papaya\", \"dragonfruit\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(s_sliced=nw.col(\"s\").str.slice(4, length=3))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n             s s_sliced\n0         pear\n1         None     None\n2       papaya       ya\n3  dragonfruit      onf\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 s           \u2506 s_sliced \u2502\n\u2502 ---         \u2506 ---      \u2502\n\u2502 str         \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 pear        \u2506          \u2502\n\u2502 null        \u2506 null     \u2502\n\u2502 papaya      \u2506 ya       \u2502\n\u2502 dragonfruit \u2506 onf      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Using negative indexes:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(s_sliced=nw.col(\"s\").str.slice(-3))\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pd)\n             s s_sliced\n0         pear      ear\n1         None     None\n2       papaya      aya\n3  dragonfruit      uit\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 s           \u2506 s_sliced \u2502\n\u2502 ---         \u2506 ---      \u2502\n\u2502 str         \u2506 str      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 pear        \u2506 ear      \u2502\n\u2502 null        \u2506 null     \u2502\n\u2502 papaya      \u2506 aya      \u2502\n\u2502 dragonfruit \u2506 uit      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.starts_with","title":"<code>starts_with(prefix)</code>","text":"<p>Check if string values start with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"fruits\": [\"apple\", \"mango\", None]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(has_prefix=nw.col(\"fruits\").str.starts_with(\"app\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n  fruits has_prefix\n0  apple       True\n1  mango      False\n2   None       None\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fruits \u2506 has_prefix \u2502\n\u2502 ---    \u2506 ---        \u2502\n\u2502 str    \u2506 bool       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 apple  \u2506 true       \u2502\n\u2502 mango  \u2506 false      \u2502\n\u2502 null   \u2506 null       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.tail","title":"<code>tail(n=5)</code>","text":"<p>Take the last n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is not supported.</p> <code>5</code> Notes <p>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"lyrics\": [\"Atatata\", \"taata\", \"taatatata\", \"zukkyun\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(lyrics_tail=nw.col(\"lyrics\").str.tail())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n      lyrics lyrics_tail\n0    Atatata       atata\n1      taata       taata\n2  taatatata       atata\n3    zukkyun       kkyun\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (4, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 lyrics    \u2506 lyrics_tail \u2502\n\u2502 ---       \u2506 ---         \u2502\n\u2502 str       \u2506 str         \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 Atatata   \u2506 atata       \u2502\n\u2502 taata     \u2506 taata       \u2502\n\u2502 taatatata \u2506 atata       \u2502\n\u2502 zukkyun   \u2506 kkyun       \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_datetime","title":"<code>to_datetime(format)</code>","text":"<p>Convert to Datetime dtype.</p> Notes <p>pandas defaults to nanosecond time unit, Polars to microsecond. Prior to pandas 2.0, nanoseconds were the only time unit supported in pandas, with no ability to set any other one. The ability to set the time unit in pandas, if the version permits, will arrive.</p> <p>Parameters:</p> Name Type Description Default <code>format</code> <code>str</code> <p>Format to parse strings with. Must be passed, as different     dataframe libraries have different ways of auto-inferring     formats.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [\"2020-01-01\", \"2020-01-02\"]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [\"2020-01-01\", \"2020-01-02\"]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\").str.to_datetime(format=\"%Y-%m-%d\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n           a\n0 2020-01-01\n1 2020-01-02\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a                   \u2502\n\u2502 ---                 \u2502\n\u2502 datetime[\u03bcs]        \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2020-01-01 00:00:00 \u2502\n\u2502 2020-01-02 00:00:00 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_lowercase","title":"<code>to_lowercase()</code>","text":"<p>Transform string to lowercase variant.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"fruits\": [\"APPLE\", \"MANGO\", None]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(lower_col=nw.col(\"fruits\").str.to_lowercase())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n  fruits  lower_col\n0  APPLE      apple\n1  MANGO      mango\n2   None       None\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fruits \u2506 lower_col \u2502\n\u2502 ---    \u2506 ---       \u2502\n\u2502 str    \u2506 str       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 APPLE  \u2506 apple     \u2502\n\u2502 MANGO  \u2506 mango     \u2502\n\u2502 null   \u2506 null      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/expr_str/#narwhals.expr.ExprStringNamespace.to_uppercase","title":"<code>to_uppercase()</code>","text":"<p>Transform string to uppercase variant.</p> Notes <p>The PyArrow backend will convert '\u00df' to '\u1e9e' instead of 'SS'. For more info see the related issue. There may be other unicode-edge-case-related variations across implementations.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"fruits\": [\"apple\", \"mango\", None]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(upper_col=nw.col(\"fruits\").str.to_uppercase())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   fruits upper_col\n0  apple     APPLE\n1  mango     MANGO\n2   None      None\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 fruits \u2506 upper_col \u2502\n\u2502 ---    \u2506 ---       \u2502\n\u2502 str    \u2506 str       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 apple  \u2506 APPLE     \u2502\n\u2502 mango  \u2506 MANGO     \u2502\n\u2502 null   \u2506 null      \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/group_by/","title":"<code>narwhals.GroupBy</code>","text":""},{"location":"api-reference/group_by/#narwhals.group_by.GroupBy.agg","title":"<code>agg(*aggs, **named_aggs)</code>","text":"<p>Compute aggregations for each group of a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>aggs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Aggregations to compute for each group of the group by operation, specified as positional arguments.</p> <code>()</code> <code>named_aggs</code> <code>IntoExpr</code> <p>Additional aggregations, specified as keyword arguments.</p> <code>{}</code> <p>Examples:</p> <p>Group by one column or by multiple columns and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n&gt;&gt;&gt; df_pl = pl.DataFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...         \"b\": [1, 2, 1, 3, 3],\n...         \"c\": [5, 4, 3, 2, 1],\n...     }\n... )\n</code></pre> <p>We define library agnostic functions:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.group_by(\"a\").agg(nw.col(\"b\").sum()).sort(\"a\")\n</code></pre> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func_mult_col(df):\n...     return df.group_by(\"a\", \"b\").agg(nw.sum(\"c\")).sort(\"a\", \"b\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code> and <code>func_mult_col</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  a  2\n1  b  5\n2  c  3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 2   \u2502\n\u2502 b   \u2506 5   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func_mult_col(df_pd)\n   a  b  c\n0  a  1  8\n1  b  2  4\n2  b  3  2\n3  c  3  1\n&gt;&gt;&gt; func_mult_col(df_pl)\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2506 8   \u2502\n\u2502 b   \u2506 2   \u2506 4   \u2502\n\u2502 b   \u2506 3   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/","title":"<code>narwhals.LazyFrame</code>","text":"<p>Narwhals DataFrame, backed by a native dataframe.</p> <p>The native dataframe might be pandas.DataFrame, polars.LazyFrame, ...</p> <p>This class is not meant to be instantiated directly - instead, use <code>narwhals.from_native</code>.</p>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.columns","title":"<code>columns: list[str]</code>  <code>property</code>","text":"<p>Get column names.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.columns\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n['foo', 'bar', 'ham']\n&gt;&gt;&gt; func(lf_pl)\n['foo', 'bar', 'ham']\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.schema","title":"<code>schema: Schema</code>  <code>property</code>","text":"<p>Get an ordered mapping of column names to their data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6.0, 7.0, 8.0],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.from_native(lf_pl)\n&gt;&gt;&gt; lf.schema\nSchema({'foo': Int64, 'bar': Float64, 'ham', String})\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.clone","title":"<code>clone()</code>","text":"<p>Create a copy of this DataFrame.</p> <p>import narwhals as nw import pandas as pd import polars as pl data = {\"a\": [1, 2], \"b\": [3, 4]} df_pd = pd.DataFrame(data) df_pl = pl.LazyFrame(data)</p> <p>Let's define a dataframe-agnostic function in which we copy the DataFrame:</p> <p>@nw.narwhalify ... def func(df): ...     return df.clone()</p> <p>func(df_pd)    a  b 0  1  3 1  2  4</p> <p>func(df_pl).collect() shape: (2, 2) \u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510 \u2502 a   \u2506 b   \u2502 \u2502 --- \u2506 --- \u2502 \u2502 i64 \u2506 i64 \u2502 \u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561 \u2502 1   \u2506 3   \u2502 \u2502 2   \u2506 4   \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518</p>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.collect","title":"<code>collect()</code>","text":"<p>Materialize this LazyFrame into a DataFrame.</p> <p>Returns:</p> Type Description <code>DataFrame[Any]</code> <p>DataFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"a\": [\"a\", \"b\", \"a\", \"b\", \"b\", \"c\"],\n...         \"b\": [1, 2, 3, 4, 5, 6],\n...         \"c\": [6, 5, 4, 3, 2, 1],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.from_native(lf_pl)\n&gt;&gt;&gt; lf\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n| Narwhals LazyFrame                            |\n| Use `narwhals.to_native` to see native output |\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; df = lf.group_by(\"a\").agg(nw.all().sum()).collect()\n&gt;&gt;&gt; nw.to_native(df).sort(\"a\")\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 4   \u2506 10  \u2502\n\u2502 b   \u2506 11  \u2506 10  \u2502\n\u2502 c   \u2506 6   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.collect_schema","title":"<code>collect_schema()</code>","text":"<p>Get an ordered mapping of column names to their data type.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(\n...     {\n...         \"foo\": [1, 2, 3],\n...         \"bar\": [6.0, 7.0, 8.0],\n...         \"ham\": [\"a\", \"b\", \"c\"],\n...     }\n... )\n&gt;&gt;&gt; lf = nw.from_native(lf_pl)\n&gt;&gt;&gt; lf.collect_schema()\nSchema({'foo': Int64, 'bar': Float64, 'ham', String})\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.drop","title":"<code>drop(*columns)</code>","text":"<p>Remove columns from the LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*columns</code> <code>str | Iterable[str]</code> <p>Names of the columns that should be removed from the       dataframe. Accepts column selector input.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.drop(\"ham\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1  6.0\n1    2  7.0\n2    3  8.0\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6.0 \u2502\n\u2502 2   \u2506 7.0 \u2502\n\u2502 3   \u2506 8.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use positional arguments to drop multiple columns.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.drop(\"foo\", \"ham\")\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pd)\n   bar\n0  6.0\n1  7.0\n2  8.0\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 bar \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 6.0 \u2502\n\u2502 7.0 \u2502\n\u2502 8.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.drop_nulls","title":"<code>drop_nulls()</code>","text":"<p>Drop null values.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1.0, 2.0, None], \"ba\": [1.0, None, 2.0]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.drop_nulls()\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a   ba\n0  1.0  1.0\n&gt;&gt;&gt; func(df_pl).collect()\nshape: (1, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 ba  \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 f64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1.0 \u2506 1.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.filter","title":"<code>filter(*predicates)</code>","text":"<p>Filter the rows in the LazyFrame based on a predicate expression.</p> <p>The original order of the remaining rows is preserved.</p> <p>Parameters:</p> Name Type Description Default <code>*predicates</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Expression that evaluates to a boolean Series.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6, 7, 8],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we filter on one condition.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter(nw.col(\"foo\") &gt; 1)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n1    2    7   b\n2    3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 7   \u2506 b   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 7   \u2506 b   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter on multiple conditions:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter((nw.col(\"foo\") &lt; 3) &amp; (nw.col(\"ham\") == \"a\"))\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Provide multiple filters using <code>*args</code> syntax:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     dframe = df.filter(\n...         nw.col(\"foo\") == 1,\n...         nw.col(\"ham\") == \"a\",\n...     )\n...     return dframe\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Filter on an OR condition:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.filter((nw.col(\"foo\") == 1) | (nw.col(\"ham\") == \"c\"))\n&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1    6   a\n2    3    8   c\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (2, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2506 a   \u2502\n\u2502 3   \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.gather_every","title":"<code>gather_every(n, offset=0)</code>","text":"<p>Take every nth row in the DataFrame and return as a new DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Gather every n-th row.</p> required <code>offset</code> <code>int</code> <p>Starting index.</p> <code>0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3, 4], \"b\": [5, 6, 7, 8]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function in which gather every 2 rows, starting from a offset of 1:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df_any):\n...     return df_any.gather_every(n=2, offset=1)\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n1  2  6\n3  4  8\n</code></pre> <pre><code>&gt;&gt;&gt; func(lf_pl).collect()\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 6   \u2502\n\u2502 4   \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.group_by","title":"<code>group_by(*keys)</code>","text":"<p>Start a group by operation.</p> <p>Parameters:</p> Name Type Description Default <code>*keys</code> <code>str | Iterable[str]</code> <p>Column(s) to group by. Accepts expression input. Strings are parsed as column names.</p> <code>()</code> <p>Examples:</p> <p>Group by one column and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"a\": [\"a\", \"b\", \"a\", \"b\", \"c\"],\n...     \"b\": [1, 2, 1, 3, 3],\n...     \"c\": [5, 4, 3, 2, 1],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we group by one column and call <code>agg</code> to compute the grouped sum of another column.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.group_by(\"a\").agg(nw.col(\"b\").sum()).sort(\"a\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  a  2\n1  b  5\n2  c  3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 2   \u2502\n\u2502 b   \u2506 5   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 2   \u2502\n\u2502 b   \u2506 5   \u2502\n\u2502 c   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Group by multiple columns by passing a list of column names.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.group_by([\"a\", \"b\"]).agg(nw.max(\"c\")).sort([\"a\", \"b\"])\n&gt;&gt;&gt; func(df_pd)\n   a  b  c\n0  a  1  5\n1  b  2  4\n2  b  3  2\n3  c  3  1\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2506 5   \u2502\n\u2502 b   \u2506 2   \u2506 4   \u2502\n\u2502 b   \u2506 3   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (4, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 str \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 a   \u2506 1   \u2506 5   \u2502\n\u2502 b   \u2506 2   \u2506 4   \u2502\n\u2502 b   \u2506 3   \u2506 2   \u2502\n\u2502 c   \u2506 3   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.head","title":"<code>head(n=5)</code>","text":"<p>Get the first <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\n...     \"a\": [1, 2, 3, 4, 5, 6],\n...     \"b\": [7, 8, 9, 10, 11, 12],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that gets the first 3 rows.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.head(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  7\n1  2  8\n2  3  9\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 7   \u2502\n\u2502 2   \u2506 8   \u2502\n\u2502 3   \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 7   \u2502\n\u2502 2   \u2506 8   \u2502\n\u2502 3   \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.join","title":"<code>join(other, *, how='inner', left_on=None, right_on=None)</code>","text":"<p>Add a join operation to the Logical Plan.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Self</code> <p>Lazy DataFrame to join with.</p> required <code>how</code> <code>Literal['inner', 'left', 'cross', 'semi', 'anti']</code> <p>Join strategy.</p> <ul> <li>inner: Returns rows that have matching values in both tables.</li> <li>cross: Returns the Cartesian product of rows from both tables.</li> <li>semi: Filter rows that have a match in the right table.</li> <li>anti: Filter rows that do not have a match in the right table.</li> </ul> <code>'inner'</code> <code>left_on</code> <code>str | list[str] | None</code> <p>Join column of the left DataFrame.</p> <code>None</code> <code>right_on</code> <code>str | list[str] | None</code> <p>Join column of the right DataFrame.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>A new joined LazyFrame</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6.0, 7.0, 8.0],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; data_other = {\n...     \"apple\": [\"x\", \"y\", \"z\"],\n...     \"ham\": [\"a\", \"b\", \"d\"],\n... }\n</code></pre> <pre><code>&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; other_pd = pd.DataFrame(data_other)\n</code></pre> <pre><code>&gt;&gt;&gt; df_pl = pl.LazyFrame(data)\n&gt;&gt;&gt; other_pl = pl.LazyFrame(data_other)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we join over \"ham\" column:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def join_on_ham(df, other_any):\n...     return df.join(other_any, left_on=\"ham\", right_on=\"ham\")\n</code></pre> <p>We can now pass either pandas or Polars to the function:</p> <pre><code>&gt;&gt;&gt; join_on_ham(df_pd, other_pd)\n   foo  bar ham apple\n0    1  6.0   a     x\n1    2  7.0   b     y\n</code></pre> <pre><code>&gt;&gt;&gt; join_on_ham(df_pl, other_pl).collect()\nshape: (2, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2506 apple \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 f64 \u2506 str \u2506 str   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6.0 \u2506 a   \u2506 x     \u2502\n\u2502 2   \u2506 7.0 \u2506 b   \u2506 y     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.lazy","title":"<code>lazy()</code>","text":"<p>Lazify the DataFrame (if possible).</p> <p>If a library does not support lazy execution, then this is a no-op.</p> <p>Examples:</p> <p>Construct pandas and Polars objects:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\"foo\": [1, 2, 3], \"bar\": [6.0, 7.0, 8.0], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.LazyFrame(df)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.lazy()\n</code></pre> <p>Note that then, pandas dataframe stay eager, and the Polars LazyFrame stays lazy:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo  bar ham\n0    1  6.0   a\n1    2  7.0   b\n2    3  8.0   c\n&gt;&gt;&gt; func(df_pl)\n&lt;LazyFrame ...&gt;\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.pipe","title":"<code>pipe(function, *args, **kwargs)</code>","text":"<p>Pipe function call.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"ba\": [4, 5, 6]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.pipe(lambda _df: _df.select(\"a\"))\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  1\n1  2\n2  3\n&gt;&gt;&gt; func(df_pl).collect()\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.rename","title":"<code>rename(mapping)</code>","text":"<p>Rename column names.</p> <p>Parameters:</p> Name Type Description Default <code>mapping</code> <code>dict[str, str]</code> <p>Key value pairs that map from old name to new name, or a       function that takes the old name as input and returns the       new name.</p> required Notes <p>If existing names are swapped (e.g. 'A' points to 'B' and 'B'  points to 'A'), polars will block projection and predicate  pushdowns at this node.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"foo\": [1, 2, 3], \"bar\": [6, 7, 8], \"ham\": [\"a\", \"b\", \"c\"]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.rename({\"foo\": \"apple\"})\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   apple  bar ham\n0      1    6   a\n1      2    7   b\n2      3    8   c\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 apple \u2506 bar \u2506 ham \u2502\n\u2502 ---   \u2506 --- \u2506 --- \u2502\n\u2502 i64   \u2506 i64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1     \u2506 6   \u2506 a   \u2502\n\u2502 2     \u2506 7   \u2506 b   \u2502\n\u2502 3     \u2506 8   \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.select","title":"<code>select(*exprs, **named_exprs)</code>","text":"<p>Select columns from this LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to select, specified as positional arguments.      Accepts expression input. Strings are parsed as column names,      other non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to select, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"foo\": [1, 2, 3],\n...     \"bar\": [6, 7, 8],\n...     \"ham\": [\"a\", \"b\", \"c\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we pass the name of a column to select that column.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\"foo\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo\n0    1\n1    2\n2    3\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Multiple columns can be selected by passing a list of column names.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select([\"foo\", \"bar\"])\n&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1    6\n1    2    7\n2    3    8\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2502\n\u2502 2   \u2506 7   \u2502\n\u2502 3   \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 6   \u2502\n\u2502 2   \u2506 7   \u2502\n\u2502 3   \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Multiple columns can also be selected using positional arguments instead of a list. Expressions are also accepted.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"foo\"), nw.col(\"bar\") + 1)\n&gt;&gt;&gt; func(df_pd)\n   foo  bar\n0    1    7\n1    2    8\n2    3    9\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 7   \u2502\n\u2502 2   \u2506 8   \u2502\n\u2502 3   \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 7   \u2502\n\u2502 2   \u2506 8   \u2502\n\u2502 3   \u2506 9   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Use keyword arguments to easily name your expression inputs.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(threshold=nw.col(\"foo\") * 2)\n&gt;&gt;&gt; func(df_pd)\n   threshold\n0          2\n1          4\n2          6\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 threshold \u2502\n\u2502 ---       \u2502\n\u2502 i64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2         \u2502\n\u2502 4         \u2502\n\u2502 6         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 threshold \u2502\n\u2502 ---       \u2502\n\u2502 i64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2         \u2502\n\u2502 4         \u2502\n\u2502 6         \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.sort","title":"<code>sort(by, *more_by, descending=False)</code>","text":"<p>Sort the LazyFrame by the given columns.</p> <p>Parameters:</p> Name Type Description Default <code>by</code> <code>str | Iterable[str]</code> <p>Column(s) to sort by. Accepts expression input. Strings are  parsed as column names.</p> required <code>*more_by</code> <code>str</code> <p>Additional columns to sort by, specified as positional        arguments.</p> <code>()</code> <code>descending</code> <code>bool | Sequence[bool]</code> <p>Sort in descending order. When sorting by multiple          columns, can be specified per column by passing a          sequence of booleans.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\n...     \"a\": [1, 2, None],\n...     \"b\": [6.0, 5.0, 4.0],\n...     \"c\": [\"a\", \"c\", \"b\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_lf = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we sort by multiple columns in different orders</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.sort(\"c\", \"a\", descending=[False, True])\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a    b  c\n0  1.0  6.0  a\n2  NaN  4.0  b\n1  2.0  5.0  c\n&gt;&gt;&gt; func(df_lf).collect()\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b   \u2506 c   \u2502\n\u2502 ---  \u2506 --- \u2506 --- \u2502\n\u2502 i64  \u2506 f64 \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1    \u2506 6.0 \u2506 a   \u2502\n\u2502 null \u2506 4.0 \u2506 b   \u2502\n\u2502 2    \u2506 5.0 \u2506 c   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.tail","title":"<code>tail(n=5)</code>","text":"<p>Get the last <code>n</code> rows.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of rows to return.</p> <code>5</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = {\n...     \"a\": [1, 2, 3, 4, 5, 6],\n...     \"b\": [7, 8, 9, 10, 11, 12],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that gets the last 3 rows.</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.tail(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a   b\n3  4  10\n4  5  11\n5  6  12\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4   \u2506 10  \u2502\n\u2502 5   \u2506 11  \u2502\n\u2502 6   \u2506 12  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4   \u2506 10  \u2502\n\u2502 5   \u2506 11  \u2502\n\u2502 6   \u2506 12  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.unique","title":"<code>unique(subset=None, *, keep='any', maintain_order=False)</code>","text":"<p>Drop duplicate rows from this LazyFrame.</p> <p>Parameters:</p> Name Type Description Default <code>subset</code> <code>str | list[str] | None</code> <p>Column name(s) to consider when identifying duplicate rows.      If set to <code>None</code>, use all columns.</p> <code>None</code> <code>keep</code> <code>Literal['any', 'first', 'last', 'none']</code> <p>{'first', 'last', 'any', 'none'} Which of the duplicate rows to keep.</p> <ul> <li>'any': Does not give any guarantee of which row is kept.         This allows more optimizations.</li> <li>'none': Don't keep duplicate rows.</li> <li>'first': Keep first unique row.</li> <li>'last': Keep last unique row.</li> </ul> <code>'any'</code> <code>maintain_order</code> <code>bool</code> <p>Keep the same order as the original DataFrame. This is more expensive to compute. Settings this to <code>True</code> blocks the possibility to run on the streaming engine for polars.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>LazyFrame</code> <code>Self</code> <p>LazyFrame with unique rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"foo\": [1, 2, 3, 1],\n...     \"bar\": [\"a\", \"a\", \"a\", \"a\"],\n...     \"ham\": [\"b\", \"b\", \"b\", \"b\"],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.unique([\"bar\", \"ham\"])\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   foo bar ham\n0    1   a   b\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 foo \u2506 bar \u2506 ham \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 str \u2506 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 a   \u2506 b   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.with_columns","title":"<code>with_columns(*exprs, **named_exprs)</code>","text":"<p>Add columns to this LazyFrame.</p> <p>Added columns will replace existing columns with the same name.</p> <p>Parameters:</p> Name Type Description Default <code>*exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Column(s) to add, specified as positional arguments.      Accepts expression input. Strings are parsed as column names, other      non-expression inputs are parsed as literals.</p> <code>()</code> <code>**named_exprs</code> <code>IntoExpr</code> <p>Additional columns to add, specified as keyword arguments.             The columns will be renamed to the keyword used.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>LazyFrame</code> <code>Self</code> <p>A new LazyFrame with the columns added.</p> Note <p>Creating a new LazyFrame using this method does not create a new copy of existing data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = {\n...     \"a\": [1, 2, 3, 4],\n...     \"b\": [0.5, 4, 10, 13],\n...     \"c\": [True, True, False, True],\n... }\n&gt;&gt;&gt; df_pd = pd.DataFrame(df)\n&gt;&gt;&gt; df_pl = pl.DataFrame(df)\n&gt;&gt;&gt; lf_pl = pl.LazyFrame(df)\n</code></pre> <p>Let's define a dataframe-agnostic function in which we pass an expression to add it as a new column:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns((nw.col(\"a\") * 2).alias(\"2a\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a     b      c  2a\n0  1   0.5   True   2\n1  2   4.0   True   4\n2  3  10.0  False   6\n3  4  13.0   True   8\n&gt;&gt;&gt; func(df_pl)\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b    \u2506 c     \u2506 2a  \u2502\n\u2502 --- \u2506 ---  \u2506 ---   \u2506 --- \u2502\n\u2502 i64 \u2506 f64  \u2506 bool  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 0.5  \u2506 true  \u2506 2   \u2502\n\u2502 2   \u2506 4.0  \u2506 true  \u2506 4   \u2502\n\u2502 3   \u2506 10.0 \u2506 false \u2506 6   \u2502\n\u2502 4   \u2506 13.0 \u2506 true  \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(lf_pl).collect()\nshape: (4, 4)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b    \u2506 c     \u2506 2a  \u2502\n\u2502 --- \u2506 ---  \u2506 ---   \u2506 --- \u2502\n\u2502 i64 \u2506 f64  \u2506 bool  \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 0.5  \u2506 true  \u2506 2   \u2502\n\u2502 2   \u2506 4.0  \u2506 true  \u2506 4   \u2502\n\u2502 3   \u2506 10.0 \u2506 false \u2506 6   \u2502\n\u2502 4   \u2506 13.0 \u2506 true  \u2506 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/lazyframe/#narwhals.dataframe.LazyFrame.with_row_index","title":"<code>with_row_index(name='index')</code>","text":"<p>Insert column which enumerates rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [4, 5, 6]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.LazyFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_row_index()\n</code></pre> <p>We can then pass either pandas or Polars:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   index  a  b\n0      0  1  4\n1      1  2  5\n2      2  3  6\n&gt;&gt;&gt; func(df_pl).collect()\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 index \u2506 a   \u2506 b   \u2502\n\u2502 ---   \u2506 --- \u2506 --- \u2502\n\u2502 u32   \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0     \u2506 1   \u2506 4   \u2502\n\u2502 1     \u2506 2   \u2506 5   \u2502\n\u2502 2     \u2506 3   \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/","title":"Top-level functions","text":"<p>Here are the top-level functions available in Narwhals.</p>"},{"location":"api-reference/narwhals/#narwhals.all","title":"<code>all()</code>","text":"<p>Instantiate an expression representing all columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [4, 5, 6]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.all() * 2)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a   b\n0  2   8\n1  4  10\n2  6  12\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 8   \u2502\n\u2502 4   \u2506 10  \u2502\n\u2502 6   \u2506 12  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.all_horizontal","title":"<code>all_horizontal(*exprs)</code>","text":"<p>Compute the bitwise AND horizontally across columns.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> Notes <p>pandas and Polars handle null values differently.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"a\": [False, False, True, True, False, None],\n...     \"b\": [False, True, True, None, None, None],\n... }\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\"a\", \"b\", all=nw.all_horizontal(\"a\", \"b\"))\n</code></pre> <p>We can then pass either pandas or polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a      b    all\n0  False  False  False\n1  False   True  False\n2   True   True   True\n3   True   None  False\n4  False   None  False\n5   None   None  False\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b     \u2506 all   \u2502\n\u2502 ---   \u2506 ---   \u2506 ---   \u2502\n\u2502 bool  \u2506 bool  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2506 false \u2506 false \u2502\n\u2502 false \u2506 true  \u2506 false \u2502\n\u2502 true  \u2506 true  \u2506 true  \u2502\n\u2502 true  \u2506 null  \u2506 null  \u2502\n\u2502 false \u2506 null  \u2506 false \u2502\n\u2502 null  \u2506 null  \u2506 null  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.any_horizontal","title":"<code>any_horizontal(*exprs)</code>","text":"<p>Compute the bitwise OR horizontally across columns.</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> Notes <p>pandas and Polars handle null values differently.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\n...     \"a\": [False, False, True, True, False, None],\n...     \"b\": [False, True, True, None, None, None],\n... }\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(\"a\", \"b\", any=nw.any_horizontal(\"a\", \"b\"))\n</code></pre> <p>We can then pass either pandas or polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       a      b    any\n0  False  False  False\n1  False   True   True\n2   True   True   True\n3   True   None   True\n4  False   None  False\n5   None   None  False\n</code></pre> <pre><code>&gt;&gt;&gt; func(df_pl)\nshape: (6, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a     \u2506 b     \u2506 any   \u2502\n\u2502 ---   \u2506 ---   \u2506 ---   \u2502\n\u2502 bool  \u2506 bool  \u2506 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2506 false \u2506 false \u2502\n\u2502 false \u2506 true  \u2506 true  \u2502\n\u2502 true  \u2506 true  \u2506 true  \u2502\n\u2502 true  \u2506 null  \u2506 true  \u2502\n\u2502 false \u2506 null  \u2506 null  \u2502\n\u2502 null  \u2506 null  \u2506 null  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.col","title":"<code>col(*names)</code>","text":"<p>Creates an expression that references one or more columns by their name(s).</p> <p>Parameters:</p> Name Type Description Default <code>names</code> <code>str | Iterable[str]</code> <p>Name(s) of the columns to use in the aggregation function.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [3, 4]})\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [3, 4]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.col(\"a\") * nw.col(\"b\"))\n</code></pre> <p>We can then pass either pandas or polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  3\n1  8\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3   \u2502\n\u2502 8   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.concat","title":"<code>concat(items, *, how='vertical')</code>","text":""},{"location":"api-reference/narwhals/#narwhals.from_dict","title":"<code>from_dict(data, schema=None, *, native_namespace)</code>","text":"<p>Instantiate DataFrame from dictionary.</p> Notes <p>For pandas-like dataframes, conversion to schema is applied after dataframe creation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict[str, Any]</code> <p>Dictionary to create DataFrame from.</p> required <code>schema</code> <code>dict[str, DType] | Schema | None</code> <p>The DataFrame schema as Schema or dict of {name: type}.</p> <code>None</code> <code>native_namespace</code> <code>ModuleType</code> <p>The native library to use for DataFrame creation.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = {\"a\": [1, 2, 3], \"b\": [4, 5, 6]}\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     data = {\"c\": [5, 2], \"d\": [1, 4]}\n...     native_namespace = nw.get_native_namespace(df)\n...     return nw.from_dict(data, native_namespace=native_namespace)\n</code></pre> <p>Let's see what happens when passing pandas / Polars input:</p> <pre><code>&gt;&gt;&gt; func(pd.DataFrame(data))\n   c  d\n0  5  1\n1  2  4\n&gt;&gt;&gt; func(pl.DataFrame(data))\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 c   \u2506 d   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 5   \u2506 1   \u2502\n\u2502 2   \u2506 4   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.from_native","title":"<code>from_native(native_object, *, strict=True, eager_only=None, eager_or_interchange_only=None, series_only=None, allow_series=None)</code>","text":"<p>Convert dataframe/series to Narwhals DataFrame, LazyFrame, or Series.</p> <p>Parameters:</p> Name Type Description Default <code>native_object</code> <code>Any</code> <p>Raw object from user. Depending on the other arguments, input object can be:</p> <ul> <li>pandas.DataFrame</li> <li>polars.DataFrame</li> <li>polars.LazyFrame</li> <li>anything with a <code>__narwhals_dataframe__</code> or <code>__narwhals_lazyframe__</code> method</li> <li>pandas.Series</li> <li>polars.Series</li> <li>anything with a <code>__narwhals_series__</code> method</li> </ul> required <code>strict</code> <code>bool</code> <p>Whether to raise if object can't be converted (default) or to just leave it as-is.</p> <code>True</code> <code>eager_only</code> <code>bool | None</code> <p>Whether to only allow eager objects.</p> <code>None</code> <code>eager_or_interchange_only</code> <code>bool | None</code> <p>Whether to only allow eager objects or objects which implement the Dataframe Interchange Protocol.</p> <code>None</code> <code>series_only</code> <code>bool | None</code> <p>Whether to only allow series.</p> <code>None</code> <code>allow_series</code> <code>bool | None</code> <p>Whether to allow series (default is only dataframe / lazyframe).</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>narwhals.DataFrame or narwhals.LazyFrame or narwhals.Series</p>"},{"location":"api-reference/narwhals/#narwhals.get_level","title":"<code>get_level(obj)</code>","text":"<p>Level of support Narwhals has for current object.</p> <p>This can be one of:</p> <ul> <li>'full': full Narwhals API support</li> <li>'metadata': only metadata operations are supported (<code>df.schema</code>)</li> </ul>"},{"location":"api-reference/narwhals/#narwhals.get_native_namespace","title":"<code>get_native_namespace(obj)</code>","text":"<p>Get native namespace from object.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df = nw.from_native(pd.DataFrame({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.get_native_namespace(df)\n&lt;module 'pandas'...&gt;\n&gt;&gt;&gt; df = nw.from_native(pl.DataFrame({\"a\": [1, 2, 3]}))\n&gt;&gt;&gt; nw.get_native_namespace(df)\n&lt;module 'polars'...&gt;\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.is_ordered_categorical","title":"<code>is_ordered_categorical(series)</code>","text":"<p>Return whether indices of categories are semantically meaningful.</p> <p>This is a convenience function to accessing what would otherwise be the <code>is_ordered</code> property from the DataFrame Interchange Protocol, see https://data-apis.org/dataframe-protocol/latest/API.html.</p> <ul> <li>For Polars:</li> <li>Enums are always ordered.</li> <li>Categoricals are ordered if <code>dtype.ordering == \"physical\"</code>.</li> <li>For pandas-like APIs:</li> <li>Categoricals are ordered if <code>dtype.cat.ordered == True</code>.</li> <li>For PyArrow table:</li> <li>Categoricals are ordered if <code>dtype.type.ordered == True</code>.</li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = [\"x\", \"y\"]\n&gt;&gt;&gt; s_pd = pd.Series(data, dtype=pd.CategoricalDtype(ordered=True))\n&gt;&gt;&gt; s_pl = pl.Series(data, dtype=pl.Categorical(ordering=\"physical\"))\n</code></pre> <p>Let's define a library-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return nw.is_ordered_categorical(s)\n</code></pre> <p>Then, we can pass any supported library to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nTrue\n&gt;&gt;&gt; func(s_pl)\nTrue\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.len","title":"<code>len()</code>","text":"<p>Return the number of rows.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.len())\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   len\n0    2\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 len \u2502\n\u2502 --- \u2502\n\u2502 u32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_align_index","title":"<code>maybe_align_index(lhs, rhs)</code>","text":"<p>Align <code>lhs</code> to the Index of `rhs, if they're both pandas-like.</p> Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already aligns indices for users. If you're designing a new library, we highly encourage you to not rely on the Index. For non-pandas-like inputs, this only checks that <code>lhs</code> and <code>rhs</code> are the same length.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2]}, index=[3, 4])\n&gt;&gt;&gt; s_pd = pd.Series([6, 7], index=[4, 3])\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; s = nw.from_native(s_pd, series_only=True)\n&gt;&gt;&gt; nw.to_native(nw.maybe_align_index(df, s))\n   a\n4  2\n3  1\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_set_index","title":"<code>maybe_set_index(df, column_names)</code>","text":"<p>Set columns <code>columns</code> to be the index of <code>df</code>, if <code>df</code> is pandas-like.</p> Notes <p>This is only really intended for backwards-compatibility purposes, for example if your library already aligns indices for users. If you're designing a new library, we highly encourage you to not rely on the Index. For non-pandas-like inputs, this is a no-op.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [4, 5]})\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.to_native(nw.maybe_set_index(df, \"b\"))\n   a\nb\n4  1\n5  2\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.maybe_convert_dtypes","title":"<code>maybe_convert_dtypes(df, *args, **kwargs)</code>","text":"<p>Convert columns to the best possible dtypes using dtypes supporting <code>pd.NA</code>, if df is pandas-like.</p> Notes <p>For non-pandas-like inputs, this is a no-op. Also, <code>args</code> and <code>kwargs</code> just get passed down to the underlying library as-is.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; df_pd = pd.DataFrame(\n...     {\n...         \"a\": pd.Series([1, 2, 3], dtype=np.dtype(\"int32\")),\n...         \"b\": pd.Series([True, False, np.nan], dtype=np.dtype(\"O\")),\n...     }\n... )\n&gt;&gt;&gt; df = nw.from_native(df_pd)\n&gt;&gt;&gt; nw.to_native(nw.maybe_convert_dtypes(df)).dtypes\na             Int32\nb           boolean\ndtype: object\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.lit","title":"<code>lit(value, dtype=None)</code>","text":"<p>Return an expression representing a literal value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>The value to use as literal.</p> required <code>dtype</code> <code>DType | None</code> <p>The data type of the literal value. If not provided, the data type will be inferred.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.with_columns(nw.lit(3).alias(\"b\"))\n</code></pre> <p>We can then pass either pandas or polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a  b\n0  1  3\n1  2  3\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i32 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 3   \u2502\n\u2502 2   \u2506 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.max","title":"<code>max(*columns)</code>","text":"<p>Return the maximum value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).max()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.max(\"a\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  2\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.mean","title":"<code>mean(*columns)</code>","text":"<p>Get the mean value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).mean()</code></p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 8, 3]})\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 8, 3]})\n</code></pre> <p>We define a dataframe agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.mean(\"a\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n     a\n0  4.0\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.min","title":"<code>min(*columns)</code>","text":"<p>Return the minimum value.</p> Note <p>Syntactic sugar for <code>nw.col(columns).min()</code>.</p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2], \"b\": [5, 10]})\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.min(\"b\"))\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   b\n0  5\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 b   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 5   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.narwhalify","title":"<code>narwhalify(func=None, *, strict=False, eager_only=False, eager_or_interchange_only=False, series_only=False, allow_series=True)</code>","text":"<p>Decorate function so it becomes dataframe-agnostic.</p> <p><code>narwhalify</code> will try to convert any dataframe/series-like object into the narwhal respective DataFrame/Series, while leaving the other parameters as they are.</p> <p>Similarly, if the output of the function is a narwhals DataFrame or Series, it will be converted back to the original dataframe/series type, while if the output is another type it will be left as is.</p> <p>By setting <code>strict=True</code>, then every input and every output will be required to be a dataframe/series-like object.</p> <p>Instead of writing</p> <pre><code>import narwhals as nw\n\n\ndef func(df):\n    df = nw.from_native(df, strict=False)\n    df = df.group_by(\"a\").agg(nw.col(\"b\").sum())\n    return nw.to_native(df)\n</code></pre> <p>you can just write</p> <pre><code>import narwhals as nw\n\n\n@nw.narwhalify\ndef func(df):\n    return df.group_by(\"a\").agg(nw.col(\"b\").sum())\n</code></pre> <p>You can also pass in extra arguments, e.g.</p> <pre><code>@nw.narhwalify(eager_only=True)\n</code></pre> <p>that will get passed down to <code>nw.from_native</code>.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[..., Any] | None</code> <p>Function to wrap in a <code>from_native</code>-<code>to_native</code> block.</p> <code>None</code> <code>strict</code> <code>bool</code> <p>Whether to raise if object can't be converted or to just leave it as-is (default).</p> <code>False</code> <code>eager_only</code> <code>bool | None</code> <p>Whether to only allow eager objects.</p> <code>False</code> <code>eager_or_interchange_only</code> <code>bool | None</code> <p>Whether to only allow eager objects or objects which implement the Dataframe Interchange Protocol.</p> <code>False</code> <code>series_only</code> <code>bool | None</code> <p>Whether to only allow series.</p> <code>False</code> <code>allow_series</code> <code>bool | None</code> <p>Whether to allow series (default is only dataframe / lazyframe).</p> <code>True</code>"},{"location":"api-reference/narwhals/#narwhals.sum","title":"<code>sum(*columns)</code>","text":"<p>Sum all values.</p> Note <p>Syntactic sugar for <code>nw.col(columns).sum()</code></p> <p>Parameters:</p> Name Type Description Default <code>columns</code> <code>str</code> <p>Name(s) of the columns to use in the aggregation function</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2]})\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.sum(\"a\"))\n</code></pre> <p>We can then pass either pandas or polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a\n0  3\n&gt;&gt;&gt; func(df_pl)\nshape: (1, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.sum_horizontal","title":"<code>sum_horizontal(*exprs)</code>","text":"<p>Sum all values horizontally across columns</p> <p>Parameters:</p> Name Type Description Default <code>exprs</code> <code>IntoExpr | Iterable[IntoExpr]</code> <p>Name(s) of the columns to use in the aggregation function. Accepts expression input.</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; df_pl = pl.DataFrame({\"a\": [1, 2, 3], \"b\": [5, 10, 15]})\n&gt;&gt;&gt; df_pd = pd.DataFrame({\"a\": [1, 2, 3], \"b\": [5, 10, 15]})\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(nw.sum_horizontal(\"a\", \"b\"))\n</code></pre> <p>We can then pass either pandas or polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n    a\n0   6\n1  12\n2  18\n&gt;&gt;&gt; func(df_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 6   \u2502\n\u2502 12  \u2502\n\u2502 18  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.show_versions","title":"<code>show_versions()</code>","text":"<p>Print useful debugging information</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from narwhals import show_versions\n&gt;&gt;&gt; show_versions()  # doctest:+SKIP\n</code></pre>"},{"location":"api-reference/narwhals/#narwhals.to_native","title":"<code>to_native(narwhals_object, *, strict=True)</code>","text":"<p>Convert Narwhals object to native one.</p> <p>Parameters:</p> Name Type Description Default <code>narwhals_object</code> <code>DataFrame[IntoFrameT] | LazyFrame[IntoFrameT] | Series</code> <p>Narwhals object.</p> required <code>strict</code> <code>bool</code> <p>whether to raise on non-Narwhals input.</p> <code>True</code> <p>Returns:</p> Type Description <code>IntoFrameT | Any</code> <p>Object of class that user started with.</p>"},{"location":"api-reference/schema/","title":"<code>narwhals.Schema</code>","text":"<p>Ordered mapping of column names to their data type.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>Mapping[str, DType] | Iterable[tuple[str, DType]] | None</code> <p>Mapping[str, DType] | Iterable[tuple[str, DType]] | None The schema definition given by column names and their associated. instantiated Narwhals data type. Accepts a mapping or an iterable of tuples.</p> <code>None</code> <p>Examples:</p> <p>Define a schema by passing instantiated data types.</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; schema = nw.Schema({\"foo\": nw.Int8(), \"bar\": nw.String()})\n&gt;&gt;&gt; schema\nSchema({'foo': Int8, 'bar': String})\n</code></pre> <p>Access the data type associated with a specific column name.</p> <pre><code>&gt;&gt;&gt; schema[\"foo\"]\nInt8\n</code></pre> <p>Access various schema properties using the <code>names</code>, <code>dtypes</code>, and <code>len</code> methods.</p> <pre><code>&gt;&gt;&gt; schema.names()\n['foo', 'bar']\n&gt;&gt;&gt; schema.dtypes()\n[Int8, String]\n&gt;&gt;&gt; schema.len()\n2\n</code></pre>"},{"location":"api-reference/schema/#narwhals.schema.Schema.names","title":"<code>names()</code>","text":"<p>Get the column names of the schema.</p>"},{"location":"api-reference/schema/#narwhals.schema.Schema.dtypes","title":"<code>dtypes()</code>","text":"<p>Get the data types of the schema.</p>"},{"location":"api-reference/schema/#narwhals.schema.Schema.len","title":"<code>len()</code>","text":"<p>Get the number of columns in the schema.</p>"},{"location":"api-reference/selectors/","title":"<code>narwhals.selectors</code>","text":"<p>The following selectors are all supported. In addition, just like in Polars, the following set operations are supported:</p> <ul> <li>set intersection: <code>&amp;</code></li> <li>set union: <code>|</code></li> <li>set difference: <code>-</code></li> <li>complement: <code>~</code></li> </ul>"},{"location":"api-reference/selectors/#narwhals.selectors.boolean","title":"<code>boolean()</code>","text":"<p>Select boolean columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function to select boolean dtypes:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(ncs.boolean())\n</code></pre> <p>We can then pass either pandas or Polars dataframes:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n       c\n0  False\n1   True\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 c     \u2502\n\u2502 ---   \u2502\n\u2502 bool  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 false \u2502\n\u2502 true  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.by_dtype","title":"<code>by_dtype(*dtypes)</code>","text":"<p>Select columns based on their dtype.</p> <p>Parameters:</p> Name Type Description Default <code>dtypes</code> <code>Any</code> <p>one or data types to select</p> <code>()</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [4.1, 2.3]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function to select int64 and float64 dtypes and multiplies each value by 2:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(ncs.by_dtype(nw.Int64, nw.Float64) * 2)\n</code></pre> <p>We can then pass either pandas or Polars dataframes:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a    c\n0  2  8.2\n1  4  4.6\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 8.2 \u2502\n\u2502 4   \u2506 4.6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.categorical","title":"<code>categorical()</code>","text":"<p>Select categorical columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data).astype({\"b\": \"category\"})\n&gt;&gt;&gt; df_pl = pl.DataFrame(data, schema_overrides={\"b\": pl.Categorical})\n</code></pre> <p>Let's define a dataframe-agnostic function to select string dtypes:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(ncs.categorical())\n</code></pre> <p>We can then pass either pandas or Polars dataframes:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   b\n0  x\n1  y\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 b   \u2502\n\u2502 --- \u2502\n\u2502 cat \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 x   \u2502\n\u2502 y   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.numeric","title":"<code>numeric()</code>","text":"<p>Select numeric columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [4.1, 2.3]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function to select numeric dtypes and multiplies each value by 2:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(ncs.numeric() * 2)\n</code></pre> <p>We can then pass either pandas or Polars dataframes:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   a    c\n0  2  8.2\n1  4  4.6\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 2   \u2506 8.2 \u2502\n\u2502 4   \u2506 4.6 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/selectors/#narwhals.selectors.string","title":"<code>string()</code>","text":"<p>Select string columns.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import narwhals.selectors as ncs\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt;\n&gt;&gt;&gt; data = {\"a\": [1, 2], \"b\": [\"x\", \"y\"], \"c\": [False, True]}\n&gt;&gt;&gt; df_pd = pd.DataFrame(data)\n&gt;&gt;&gt; df_pl = pl.DataFrame(data)\n</code></pre> <p>Let's define a dataframe-agnostic function to select string dtypes:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(df):\n...     return df.select(ncs.string())\n</code></pre> <p>We can then pass either pandas or Polars dataframes:</p> <pre><code>&gt;&gt;&gt; func(df_pd)\n   b\n0  x\n1  y\n&gt;&gt;&gt; func(df_pl)\nshape: (2, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 b   \u2502\n\u2502 --- \u2502\n\u2502 str \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 x   \u2502\n\u2502 y   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/","title":"<code>narwhals.Series</code>","text":"<p>Narwhals Series, backed by a native series.</p> <p>The native dataframe might be pandas.Series, polars.Series, ...</p> <p>This class is not meant to be instantiated directly - instead, use <code>narwhals.from_native</code>, making sure to pass <code>allow_series=True</code> or <code>series_only=True</code>.</p>"},{"location":"api-reference/series/#narwhals.series.Series.dtype","title":"<code>dtype: Any</code>  <code>property</code>","text":"<p>Get the data type of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dtype\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nInt64\n&gt;&gt;&gt; func(s_pl)\nInt64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get the name of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"foo\")\n&gt;&gt;&gt; s_pl = pl.Series(\"foo\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.name\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n'foo'\n&gt;&gt;&gt; func(s_pl)\n'foo'\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.shape","title":"<code>shape: tuple[int]</code>  <code>property</code>","text":"<p>Get the shape of the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.shape\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n(3,)\n&gt;&gt;&gt; func(s_pl)\n(3,)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.abs","title":"<code>abs()</code>","text":"<p>Calculate the absolute value of each element.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [2, -4, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.abs()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2\n1    4\n2    3\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   2\n   4\n   3\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.alias","title":"<code>alias(name)</code>","text":"<p>Rename the Series.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The new name.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"foo\")\n&gt;&gt;&gt; s_pl = pl.Series(\"foo\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.alias(\"bar\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1\n1    2\n2    3\nName: bar, dtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: 'bar' [i64]\n[\n   1\n   2\n   3\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.all","title":"<code>all()</code>","text":"<p>Return whether all values in the Series are True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [True, False, True]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.all()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nnp.False_\n&gt;&gt;&gt; func(s_pl)\nFalse\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.any","title":"<code>any()</code>","text":"<p>Return whether any of the values in the Series are True.</p> Notes <p>Only works on Series of data type Boolean.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [False, True, False]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.any()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nnp.True_\n&gt;&gt;&gt; func(s_pl)\nTrue\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.arg_true","title":"<code>arg_true()</code>","text":"<p>Find elements where boolean Series is True.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [1, None, None, 2]\n&gt;&gt;&gt; s_pd = pd.Series(data, name=\"a\")\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.is_null().arg_true()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1\n1    2\nName: a, dtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: 'a' [u32]\n[\n   1\n   2\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cast","title":"<code>cast(dtype)</code>","text":"<p>Cast between data types.</p> <p>Parameters:</p> Name Type Description Default <code>dtype</code> <code>Any</code> <p>Data type that the object will be cast into.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [True, False, True]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.cast(nw.Int64)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1\n1    0\n2    1\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   1\n   0\n   1\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.count","title":"<code>count()</code>","text":"<p>Returns the number of non-null elements in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.count()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nnp.int64(3)\n&gt;&gt;&gt; func(s_pl)\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.cum_sum","title":"<code>cum_sum()</code>","text":"<p>Calculate the cumulative sum.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [2, 4, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.cum_sum()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2\n1    6\n2    9\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   2\n   6\n   9\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.diff","title":"<code>diff()</code>","text":"<p>Calculate the difference with the previous element, for each element.</p> Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to calculate the diff and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>s.diff().fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [2, 4, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.diff()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    NaN\n1    2.0\n2   -1.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   null\n   2\n   -1\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.drop_nulls","title":"<code>drop_nulls()</code>","text":"<p>Drop all null values.</p> See Also <p>drop_nans</p> Notes <p>A null value is not the same as a NaN value. To drop NaN values, use :func:<code>drop_nans</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_pd = pd.Series([2, 4, None, 3, 5])\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", [2, 4, None, 3, 5])\n</code></pre> <p>Now define a dataframe-agnostic function with a <code>column</code> argument for the column to evaluate :</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.drop_nulls()\n</code></pre> <p>Then we can pass either Series (polars or pandas) to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2.0\n1    4.0\n3    3.0\n4    5.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: 'a' [i64]\n[\n   2\n   4\n   3\n   5\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.fill_null","title":"<code>fill_null(value)</code>","text":"<p>Fill null values using the specified value.</p> <p>Parameters:</p> Name Type Description Default <code>value</code> <code>Any</code> <p>Value used to fill null values.</p> required Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, None]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.fill_null(5)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1.0\n1    2.0\n2    5.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   1\n   2\n   5\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.filter","title":"<code>filter(other)</code>","text":"<p>Filter elements in the Series based on a condition.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [4, 10, 15, 34, 50]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.filter(s &gt; 10)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n2    15\n3    34\n4    50\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   15\n   34\n   50\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.gather_every","title":"<code>gather_every(n, offset=0)</code>","text":"<p>Take every nth value in the Series and return as new Series.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Gather every n-th row.</p> required <code>offset</code> <code>int</code> <p>Starting index.</p> <code>0</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = [1, 2, 3, 4]\n&gt;&gt;&gt; s_pd = pd.Series(name=\"a\", data=data)\n&gt;&gt;&gt; s_pl = pl.Series(name=\"a\", values=data)\n</code></pre> <p>Let's define a dataframe-agnostic function in which gather every 2 rows, starting from a offset of 1:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.gather_every(n=2, offset=1)\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pd)\n1    2\n3    4\nName: a, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: 'a' [i64]\n[\n   2\n   4\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.head","title":"<code>head(n=10)</code>","text":"<p>Get the first <code>n</code> rows.</p> <p>Arguments     n : int         Number of rows to return.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = list(range(10))\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the first 3 rows:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.head(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    0\n1    1\n2    2\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   0\n   1\n   2\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_between","title":"<code>is_between(lower_bound, upper_bound, closed='both')</code>","text":"<p>Get a boolean mask of the values that are between the given lower/upper bounds.</p> <p>Parameters:</p> Name Type Description Default <code>lower_bound</code> <code>Any</code> <p>Lower bound value.</p> required <code>upper_bound</code> <code>Any</code> <p>Upper bound value.</p> required <code>closed</code> <code>str</code> <p>Define which sides of the interval are closed (inclusive).</p> <code>'both'</code> Notes <p>If the value of the <code>lower_bound</code> is greater than that of the <code>upper_bound</code>, then the values will be False, as no value can satisfy the condition.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3, 4, 5])\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.is_between(2, 4, \"right\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1    False\n2     True\n3     True\n4    False\ndtype: bool\n&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: '' [bool]\n[\n   false\n   false\n   true\n   true\n   false\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_duplicated","title":"<code>is_duplicated()</code>","text":"<p>Get a mask of all duplicated rows in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3, 1])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3, 1])\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.is_duplicated()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0     True\n1    False\n2    False\n3     True\ndtype: bool\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [bool]\n[\n    true\n    false\n    false\n    true\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_empty","title":"<code>is_empty()</code>","text":"<p>Check if the series is empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <p>Let's define a dataframe-agnostic function that filters rows in which \"foo\" values are greater than 10, and then checks if the result is empty or not:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.filter(s &gt; 10).is_empty()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3])\n&gt;&gt;&gt; func(s_pd), func(s_pl)\n(True, True)\n</code></pre> <pre><code>&gt;&gt;&gt; s_pd = pd.Series([100, 2, 3])\n&gt;&gt;&gt; s_pl = pl.Series([100, 2, 3])\n&gt;&gt;&gt; func(s_pd), func(s_pl)\n(False, False)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_first_distinct","title":"<code>is_first_distinct()</code>","text":"<p>Return a boolean mask indicating the first occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, 1, 2, 3, 2])\n&gt;&gt;&gt; s_pl = pl.Series([1, 1, 2, 3, 2])\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.is_first_distinct()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0     True\n1    False\n2     True\n3     True\n4    False\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: '' [bool]\n[\n    true\n    false\n    true\n    true\n    false\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_in","title":"<code>is_in(other)</code>","text":"<p>Check if the elements of this Series are in the other sequence.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Any</code> <p>Sequence of primitive type.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3])\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.is_in([3, 2, 8])\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1     True\n2     True\ndtype: bool\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [bool]\n[\n   false\n   true\n   true\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_last_distinct","title":"<code>is_last_distinct()</code>","text":"<p>Return a boolean mask indicating the last occurrence of each distinct value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, 1, 2, 3, 2])\n&gt;&gt;&gt; s_pl = pl.Series([1, 1, 2, 3, 2])\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.is_last_distinct()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1     True\n2    False\n3     True\n4     True\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: '' [bool]\n[\n    false\n    true\n    false\n    true\n    true\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_null","title":"<code>is_null()</code>","text":"<p>Returns a boolean Series indicating which values are null.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, None]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.is_null()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1    False\n2     True\ndtype: bool\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [bool]\n[\n   false\n   false\n   true\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_sorted","title":"<code>is_sorted(*, descending=False)</code>","text":"<p>Check if the Series is sorted.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Check if the Series is sorted in descending order.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; unsorted_data = [1, 3, 2]\n&gt;&gt;&gt; sorted_data = [3, 2, 1]\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s, descending=False):\n...     return s.is_sorted(descending=descending)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(pl.Series(unsorted_data))\nFalse\n&gt;&gt;&gt; func(pl.Series(sorted_data), descending=True)\nTrue\n&gt;&gt;&gt; func(pd.Series(unsorted_data))\nFalse\n&gt;&gt;&gt; func(pd.Series(sorted_data), descending=True)\nTrue\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.is_unique","title":"<code>is_unique()</code>","text":"<p>Get a mask of all unique rows in the Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3, 1])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3, 1])\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.is_unique()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1     True\n2     True\n3    False\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [bool]\n[\n    false\n     true\n     true\n    false\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.item","title":"<code>item(index=None)</code>","text":"<p>Return the Series as a scalar, or return the element at the given index.</p> <p>If no index is provided, this is equivalent to <code>s[0]</code>, with a check that the shape is (1,). With an index, this is equivalent to <code>s[index]</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <p>Let's define a dataframe-agnostic function that returns item at given index</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s, index=None):\n...     return s.item(index)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(pl.Series(\"a\", [1]), None), func(pd.Series([1]), None)\n(1, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; func(pl.Series(\"a\", [9, 8, 7]), -1), func(pl.Series([9, 8, 7]), -2)\n(7, 8)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.len","title":"<code>len()</code>","text":"<p>Return the number of elements in the Series.</p> <p>Null values count towards the total.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = [1, 2, None]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that computes the len of the series:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.len()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n3\n&gt;&gt;&gt; func(s_pl)\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.max","title":"<code>max()</code>","text":"<p>Get the maximum value in this Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.max()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nnp.int64(3)\n&gt;&gt;&gt; func(s_pl)\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.mean","title":"<code>mean()</code>","text":"<p>Reduce this Series to the mean value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.mean()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nnp.float64(2.0)\n&gt;&gt;&gt; func(s_pl)\n2.0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.min","title":"<code>min()</code>","text":"<p>Get the minimal value in this Series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.min()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nnp.int64(1)\n&gt;&gt;&gt; func(s_pl)\n1\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.null_count","title":"<code>null_count()</code>","text":"<p>Create a new Series that shows the null counts per column.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, None, 3])\n&gt;&gt;&gt; s_pl = pl.Series([1, None, None])\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the null count of the series:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.null_count()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n1\n&gt;&gt;&gt; func(s_pl)\n2\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.n_unique","title":"<code>n_unique()</code>","text":"<p>Count the number of unique values.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.n_unique()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n3\n&gt;&gt;&gt; func(s_pl)\n3\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.quantile","title":"<code>quantile(quantile, interpolation)</code>","text":"<p>Get quantile value of the series.</p> Note <p>pandas and Polars may have implementation differences for a given interpolation method.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <p>float Quantile between 0.0 and 1.0.</p> required <code>interpolation</code> <p>{'nearest', 'higher', 'lower', 'midpoint', 'linear'} Interpolation method.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = list(range(50))\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return [\n...         s.quantile(quantile=q, interpolation=\"nearest\")\n...         for q in (0.1, 0.25, 0.5, 0.75, 0.9)\n...     ]\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n[5, 12, 24, 37, 44]\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\n[5.0, 12.0, 25.0, 37.0, 44.0]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.round","title":"<code>round(decimals=0)</code>","text":"<p>Round underlying floating point data by <code>decimals</code> digits.</p> <p>Arguments     decimals: Number of decimals to round by.</p> Notes <p>For values exactly halfway between rounded decimal values pandas and Polars behave differently.</p> <p>pandas rounds to the nearest even value (e.g. -0.5 and 0.5 round to 0.0, 1.5 and 2.5 round to 2.0, 3.5 and 4.5 to 4.0, etc..).</p> <p>Polars rounds away from 0 (e.g. -0.5 to -1.0, 0.5 to 1.0, 1.5 to 2.0, 2.5 to 3.0, etc..).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = [1.12345, 2.56789, 3.901234]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that rounds to the first decimal:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.round(1)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1.1\n1    2.6\n2    3.9\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [f64]\n[\n   1.1\n   2.6\n   3.9\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sample","title":"<code>sample(n=None, fraction=None, *, with_replacement=False)</code>","text":"<p>Sample randomly from this Series.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int | None</code> <p>Number of items to return. Cannot be used with fraction.</p> <code>None</code> <code>fraction</code> <code>float | None</code> <p>Fraction of items to return. Cannot be used with n.</p> <code>None</code> <code>with_replacement</code> <code>bool</code> <p>Allow values to be sampled more than once.</p> <code>False</code> Notes <p>The <code>sample</code> method returns a Series with a specified number of randomly selected items chosen from this Series. The results are not consistent across libraries.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n</code></pre> <pre><code>&gt;&gt;&gt; s_pd = pd.Series([1, 2, 3, 4])\n&gt;&gt;&gt; s_pl = pl.Series([1, 2, 3, 4])\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.sample(fraction=1.0, with_replacement=True)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n   a\n2  3\n1  2\n3  4\n3  4\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [i64]\n[\n   1\n   4\n   3\n   4\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.shift","title":"<code>shift(n)</code>","text":"<p>Shift values by <code>n</code> positions.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of indices to shift forward. If a negative value is passed, values are shifted in the opposite direction instead.</p> required Notes <p>pandas may change the dtype here, for example when introducing missing values in an integer column. To ensure, that the dtype doesn't change, you may want to use <code>fill_null</code> and <code>cast</code>. For example, to shift and fill missing values with <code>0</code> in a Int64 column, you could do:</p> <pre><code>s.shift(1).fill_null(0).cast(nw.Int64)\n</code></pre> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [2, 4, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.shift(1)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    NaN\n1    2.0\n2    4.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   null\n   2\n   4\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sort","title":"<code>sort(*, descending=False, nulls_last=False)</code>","text":"<p>Sort this Series. Place null values first.</p> <p>Parameters:</p> Name Type Description Default <code>descending</code> <code>bool</code> <p>Sort in descending order.</p> <code>False</code> <code>nulls_last</code> <code>bool</code> <p>Place null values last instead of first.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [5, None, 1, 2]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define library agnostic functions:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.sort()\n</code></pre> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func_descend(s):\n...     return s.sort(descending=True)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n1    NaN\n2    1.0\n3    2.0\n0    5.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [i64]\n[\n   null\n   1\n   2\n   5\n]\n&gt;&gt;&gt; func_descend(s_pd)\n1    NaN\n0    5.0\n3    2.0\n2    1.0\ndtype: float64\n&gt;&gt;&gt; func_descend(s_pl)\nshape: (4,)\nSeries: '' [i64]\n[\n   null\n   5\n   2\n   1\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.std","title":"<code>std(*, ddof=1)</code>","text":"<p>Get the standard deviation of this Series.</p> <p>Parameters:</p> Name Type Description Default <code>ddof</code> <code>int</code> <p>\u201cDelta Degrees of Freedom\u201d: the divisor used in the calculation is N - ddof,      where N represents the number of elements.</p> <code>1</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.std()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nnp.float64(1.0)\n&gt;&gt;&gt; func(s_pl)\n1.0\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.sum","title":"<code>sum()</code>","text":"<p>Reduce this Series to the sum value.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.sum()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\nnp.int64(6)\n&gt;&gt;&gt; func(s_pl)\n6\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.tail","title":"<code>tail(n=10)</code>","text":"<p>Get the last <code>n</code> rows.</p> <p>Arguments     n : int         Number of rows to return.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = list(range(10))\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>Let's define a dataframe-agnostic function that returns the last 3 rows:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.tail(3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n7    7\n8    8\n9    9\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   7\n   8\n   9\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_dummies","title":"<code>to_dummies(*, separator='_', drop_first=False)</code>","text":"<p>Get dummy/indicator variables.</p> <p>Arguments     separator: Separator/delimiter used when generating column names.     drop_first: Remove the first category from the variable being encoded.</p> Notes <p>pandas and Polars handle null values differently. Polars distinguishes between NaN and Null, whereas pandas doesn't.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; data = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(data, name=\"a\")\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", data)\n</code></pre> <p>Let's define a dataframe-agnostic function that rounds to the first decimal:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s, drop_first: bool = False):\n...     return s.to_dummies(drop_first=drop_first)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n   a_1  a_2  a_3\n0    1    0    0\n1    0    1    0\n2    0    0    1\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pd, drop_first=True)\n   a_2  a_3\n0    0    0\n1    1    0\n2    0    1\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_1 \u2506 a_2 \u2506 a_3 \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 u8  \u2506 u8  \u2506 u8  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 0   \u2506 0   \u2502\n\u2502 0   \u2506 1   \u2506 0   \u2502\n\u2502 0   \u2506 0   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n&gt;&gt;&gt; func(s_pl, drop_first=True)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_2 \u2506 a_3 \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 u8  \u2506 u8  \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 0   \u2506 0   \u2502\n\u2502 1   \u2506 0   \u2502\n\u2502 0   \u2506 1   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_frame","title":"<code>to_frame()</code>","text":"<p>Convert to dataframe.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"a\")\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.to_frame()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n   a\n0  1\n1  2\n2  3\n&gt;&gt;&gt; func(s_pl)\nshape: (3, 1)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2502\n\u2502 --- \u2502\n\u2502 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2502\n\u2502 2   \u2502\n\u2502 3   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_list","title":"<code>to_list()</code>","text":"<p>Convert to list.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"a\")\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.to_list()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n[1, 2, 3]\n&gt;&gt;&gt; func(s_pl)\n[1, 2, 3]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_numpy","title":"<code>to_numpy()</code>","text":"<p>Convert to numpy.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"a\")\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.to_numpy()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\narray([1, 2, 3]...)\n&gt;&gt;&gt; func(s_pl)\narray([1, 2, 3]...)\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.to_pandas","title":"<code>to_pandas()</code>","text":"<p>Convert to pandas.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [1, 2, 3]\n&gt;&gt;&gt; s_pd = pd.Series(s, name=\"a\")\n&gt;&gt;&gt; s_pl = pl.Series(\"a\", s)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.to_pandas()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1\n1    2\n2    3\nName: a, dtype: int64\n&gt;&gt;&gt; func(s_pl)\n0    1\n1    2\n2    3\nName: a, dtype: int64\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.unique","title":"<code>unique()</code>","text":"<p>Returns unique values</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; s = [2, 4, 4, 6]\n&gt;&gt;&gt; s_pd = pd.Series(s)\n&gt;&gt;&gt; s_pl = pl.Series(s)\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.unique()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2\n1    4\n2    6\ndtype: int64\n&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [i64]\n[\n   2\n   4\n   6\n]\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.value_counts","title":"<code>value_counts(*, sort=False, parallel=False, name=None, normalize=False)</code>","text":"<p>Count the occurrences of unique values.</p> <p>Parameters:</p> Name Type Description Default <code>sort</code> <code>bool</code> <p>Sort the output by count in descending order. If set to False (default), the order of the output is random.</p> <code>False</code> <code>parallel</code> <code>bool</code> <p>Execute the computation in parallel. Used for Polars only.</p> <code>False</code> <code>name</code> <code>str | None</code> <p>Give the resulting count column a specific name; if <code>normalize</code> is True defaults to \"proportion\", otherwise defaults to \"count\".</p> <code>None</code> <code>normalize</code> <code>bool</code> <p>If true gives relative frequencies of the unique values</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s_pd = pd.Series([1, 1, 2, 3, 2], name=\"s\")\n&gt;&gt;&gt; s_pl = pl.Series(values=[1, 1, 2, 3, 2], name=\"s\")\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.value_counts(sort=True)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n   s  count\n0  1      2\n1  2      2\n2  3      1\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 s   \u2506 count \u2502\n\u2502 --- \u2506 ---   \u2502\n\u2502 i64 \u2506 u32   \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 2     \u2502\n\u2502 2   \u2506 2     \u2502\n\u2502 3   \u2506 1     \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"api-reference/series/#narwhals.series.Series.zip_with","title":"<code>zip_with(mask, other)</code>","text":"<p>Take values from self or other based on the given mask.</p> <p>Where mask evaluates true, take values from self. Where mask evaluates false, take values from other.</p> <p>Parameters:</p> Name Type Description Default <code>mask</code> <code>Self</code> <p>Boolean Series</p> required <code>other</code> <code>Self</code> <p>Series of same type.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; s1_pl = pl.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; s2_pl = pl.Series([5, 4, 3, 2, 1])\n&gt;&gt;&gt; mask_pl = pl.Series([True, False, True, False, True])\n&gt;&gt;&gt; s1_pd = pd.Series([1, 2, 3, 4, 5])\n&gt;&gt;&gt; s2_pd = pd.Series([5, 4, 3, 2, 1])\n&gt;&gt;&gt; mask_pd = pd.Series([True, False, True, False, True])\n</code></pre> <p>Let's define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s1_any, mask_any, s2_any):\n...     return s1_any.zip_with(mask_any, s2_any)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s1_pl, mask_pl, s2_pl)\nshape: (5,)\nSeries: '' [i64]\n[\n   1\n   4\n   3\n   2\n   5\n]\n&gt;&gt;&gt; func(s1_pd, mask_pd, s2_pd)\n0    1\n1    4\n2    3\n3    2\n4    5\ndtype: int64\n</code></pre>"},{"location":"api-reference/series_cat/","title":"<code>narwhals.Series.cat</code>","text":""},{"location":"api-reference/series_dt/","title":"<code>narwhals.Series.dt</code>","text":""},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.year","title":"<code>year()</code>","text":"<p>Get the year in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2012, 1, 7), datetime(2023, 3, 10)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.year()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2012\n1    2023\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i32]\n[\n   2012\n   2023\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.month","title":"<code>month()</code>","text":"<p>Gets the month in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2023, 2, 1), datetime(2023, 8, 3)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.month()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2\n1    8\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i8]\n[\n   2\n   8\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.day","title":"<code>day()</code>","text":"<p>Extracts the day in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2022, 1, 1), datetime(2022, 1, 5)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.day()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    1\n1    5\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i8]\n[\n   1\n   5\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.ordinal_day","title":"<code>ordinal_day()</code>","text":"<p>Get ordinal day.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [datetime(2020, 1, 1), datetime(2020, 8, 3)]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.ordinal_day()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0      1\n1    216\ndtype: int32\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i16]\n[\n   1\n   216\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.hour","title":"<code>hour()</code>","text":"<p>Extracts the hour in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2022, 1, 1, 5, 3), datetime(2022, 1, 5, 9, 12)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.hour()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    5\n1    9\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i8]\n[\n   5\n   9\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.minute","title":"<code>minute()</code>","text":"<p>Extracts the minute in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2022, 1, 1, 5, 3), datetime(2022, 1, 5, 9, 12)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.minute()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0     3\n1    12\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i8]\n[\n   3\n   12\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.second","title":"<code>second()</code>","text":"<p>Extracts the second(s) in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [datetime(2022, 1, 1, 5, 3, 10), datetime(2022, 1, 5, 9, 12, 4)]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.second()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    10\n1     4\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i8]\n[\n   10\n    4\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.millisecond","title":"<code>millisecond()</code>","text":"<p>Extracts the milliseconds in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [\n...     datetime(2023, 5, 21, 12, 55, 10, 400000),\n...     datetime(2023, 5, 21, 12, 55, 10, 600000),\n...     datetime(2023, 5, 21, 12, 55, 10, 800000),\n...     datetime(2023, 5, 21, 12, 55, 11, 0),\n...     datetime(2023, 5, 21, 12, 55, 11, 200000),\n... ]\n</code></pre> <pre><code>&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.millisecond().alias(\"datetime\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    400\n1    600\n2    800\n3      0\n4    200\nName: datetime, dtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: 'datetime' [i32]\n[\n    400\n    600\n    800\n    0\n    200\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.microsecond","title":"<code>microsecond()</code>","text":"<p>Extracts the microseconds in a datetime series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [\n...     datetime(2023, 5, 21, 12, 55, 10, 400000),\n...     datetime(2023, 5, 21, 12, 55, 10, 600000),\n...     datetime(2023, 5, 21, 12, 55, 10, 800000),\n...     datetime(2023, 5, 21, 12, 55, 11, 0),\n...     datetime(2023, 5, 21, 12, 55, 11, 200000),\n... ]\n</code></pre> <pre><code>&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.microsecond().alias(\"datetime\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    400000\n1    600000\n2    800000\n3         0\n4    200000\nName: datetime, dtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: 'datetime' [i32]\n[\n   400000\n   600000\n   800000\n   0\n   200000\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.nanosecond","title":"<code>nanosecond()</code>","text":"<p>Extracts the nanosecond(s) in a date series.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; dates = [\n...     datetime(2022, 1, 1, 5, 3, 10, 500000),\n...     datetime(2022, 1, 5, 9, 12, 4, 60000),\n... ]\n&gt;&gt;&gt; s_pd = pd.Series(dates)\n&gt;&gt;&gt; s_pl = pl.Series(dates)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.nanosecond()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    500000000\n1     60000000\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i32]\n[\n   500000000\n   60000000\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_minutes","title":"<code>total_minutes()</code>","text":"<p>Get total minutes.</p> Notes <p>The function outputs the total minutes in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [timedelta(minutes=10), timedelta(minutes=20, seconds=40)]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.total_minutes()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    10\n1    20\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        20\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_seconds","title":"<code>total_seconds()</code>","text":"<p>Get total seconds.</p> Notes <p>The function outputs the total seconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [timedelta(seconds=10), timedelta(seconds=20, milliseconds=40)]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.total_seconds()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    10\n1    20\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        20\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_milliseconds","title":"<code>total_milliseconds()</code>","text":"<p>Get total milliseconds.</p> Notes <p>The function outputs the total milliseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     timedelta(milliseconds=10),\n...     timedelta(milliseconds=20, microseconds=40),\n... ]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.total_milliseconds()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    10\n1    20\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        20\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_microseconds","title":"<code>total_microseconds()</code>","text":"<p>Get total microseconds.</p> Notes <p>The function outputs the total microseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     timedelta(microseconds=10),\n...     timedelta(milliseconds=1, microseconds=200),\n... ]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.total_microseconds()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0      10\n1    1200\ndtype: int...\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i64]\n[\n        10\n        1200\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.total_nanoseconds","title":"<code>total_nanoseconds()</code>","text":"<p>Get total nanoseconds.</p> Notes <p>The function outputs the total nanoseconds in the int dtype by default, however, pandas may change the dtype to float when there are missing values, consider using <code>fill_null()</code> in this case.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; from datetime import timedelta\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\"2024-01-01 00:00:00.000000001\", \"2024-01-01 00:00:00.000000002\"]\n&gt;&gt;&gt; s_pd = pd.to_datetime(pd.Series(data))\n&gt;&gt;&gt; s_pl = pl.Series(data).str.to_datetime(time_unit=\"ns\")\n</code></pre> <p>We define a library agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.diff().dt.total_nanoseconds()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    NaN\n1    1.0\ndtype: float64\n&gt;&gt;&gt; func(s_pl)\nshape: (2,)\nSeries: '' [i64]\n[\n        null\n        1\n]\n</code></pre>"},{"location":"api-reference/series_dt/#narwhals.series.SeriesDateTimeNamespace.to_string","title":"<code>to_string(format)</code>","text":"<p>Convert a Date/Time/Datetime series into a String series with the given format.</p> Notes <p>Unfortunately, different libraries interpret format directives a bit differently.</p> <ul> <li>Chrono, the library used by Polars, uses <code>\"%.f\"</code> for fractional seconds,   whereas pandas and Python stdlib use <code>\".%f\"</code>.</li> <li>PyArrow interprets <code>\"%S\"</code> as \"seconds, including fractional seconds\"   whereas most other tools interpret it as \"just seconds, as 2 digits\".</li> </ul> <p>Therefore, we make the following adjustments:</p> <ul> <li>for pandas-like libraries, we replace <code>\"%S.%f\"</code> with <code>\"%S%.f\"</code>.</li> <li>for PyArrow, we replace <code>\"%S.%f\"</code> with <code>\"%S\"</code>.</li> </ul> <p>Workarounds like these don't make us happy, and we try to avoid them as much as possible, but here we feel like it's the best compromise.</p> <p>If you just want to format a date/datetime Series as a local datetime string, and have it work as consistently as possible across libraries, we suggest using:</p> <ul> <li><code>\"%Y-%m-%dT%H:%M:%S%.f\"</code> for datetimes</li> <li><code>\"%Y-%m-%d\"</code> for dates</li> </ul> <p>though note that, even then, different tools may return a different number of trailing zeros. Nonetheless, this is probably consistent enough for most applications.</p> <p>If you have an application where this is not enough, please open an issue and let us know.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from datetime import datetime\n&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\n...     datetime(2020, 3, 1),\n...     datetime(2020, 4, 1),\n...     datetime(2020, 5, 1),\n... ]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.dt.to_string(\"%Y/%m/%d\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    2020/03/01\n1    2020/04/01\n2    2020/05/01\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [str]\n[\n   \"2020/03/01\"\n   \"2020/04/01\"\n   \"2020/05/01\"\n]\n</code></pre>"},{"location":"api-reference/series_str/","title":"<code>narwhals.Series.str</code>","text":""},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.contains","title":"<code>contains(pattern, *, literal=False)</code>","text":"<p>Check if string contains a substring that matches a pattern.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>str</code> <p>A Character sequence or valid regular expression pattern.</p> required <code>literal</code> <code>bool</code> <p>If True, treats the pattern as a literal string.      If False, assumes the pattern is a regular expression.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; pets = [\"cat\", \"dog\", \"rabbit and parrot\", \"dove\", None]\n&gt;&gt;&gt; s_pd = pd.Series(pets)\n&gt;&gt;&gt; s_pl = pl.Series(pets)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.str.contains(\"parrot|dove\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1    False\n2     True\n3     True\n4     None\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (5,)\nSeries: '' [bool]\n[\n   false\n   false\n   true\n   true\n   null\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.ends_with","title":"<code>ends_with(suffix)</code>","text":"<p>Check if string values end with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>suffix</code> <code>str</code> <p>suffix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\"apple\", \"mango\", None]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.str.ends_with(\"ngo\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    False\n1     True\n2     None\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [bool]\n[\n   false\n   true\n   null\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.head","title":"<code>head(n=5)</code>","text":"<p>Take the first n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is supported (see note (1.))</p> <code>5</code> Notes <ol> <li>When the <code>n</code> input is negative, <code>head</code> returns characters up to the n-th from the end of the string.     For example, if <code>n = -3</code>, then all characters except the last three are returned.</li> <li>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lyrics = [\"Atatata\", \"taata\", \"taatatata\", \"zukkyun\"]\n&gt;&gt;&gt; s_pd = pd.Series(lyrics)\n&gt;&gt;&gt; s_pl = pl.Series(lyrics)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.str.head()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    Atata\n1    taata\n2    taata\n3    zukky\ndtype: object\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [str]\n[\n   \"Atata\"\n   \"taata\"\n   \"taata\"\n   \"zukky\"\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.slice","title":"<code>slice(offset, length=None)</code>","text":"<p>Create subslices of the string values of a Series.</p> <p>Parameters:</p> Name Type Description Default <code>offset</code> <code>int</code> <p>Start index. Negative indexing is supported.</p> required <code>length</code> <code>int | None</code> <p>Length of the slice. If set to <code>None</code> (default), the slice is taken to the end of the string.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\"pear\", None, \"papaya\", \"dragonfruit\"]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.str.slice(4, length=3)\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0\n1    None\n2      ya\n3     onf\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [str]\n[\n   \"\"\n   null\n   \"ya\"\n   \"onf\"\n]\n</code></pre> <p>Using negative indexes:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.str.slice(-3)\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pd)\n0     ear\n1    None\n2     aya\n3     uit\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [str]\n[\n    \"ear\"\n    null\n    \"aya\"\n    \"uit\"\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.starts_with","title":"<code>starts_with(prefix)</code>","text":"<p>Check if string values start with a substring.</p> <p>Parameters:</p> Name Type Description Default <code>prefix</code> <code>str</code> <p>prefix substring</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; data = [\"apple\", \"mango\", None]\n&gt;&gt;&gt; s_pd = pd.Series(data)\n&gt;&gt;&gt; s_pl = pl.Series(data)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.str.starts_with(\"app\")\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0     True\n1    False\n2     None\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; func(s_pl)\nshape: (3,)\nSeries: '' [bool]\n[\n   true\n   false\n   null\n]\n</code></pre>"},{"location":"api-reference/series_str/#narwhals.series.SeriesStringNamespace.tail","title":"<code>tail(n=5)</code>","text":"<p>Take the last n elements of each string.</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>int</code> <p>Number of elements to take. Negative indexing is supported (see note (1.))</p> <code>5</code> Notes <ol> <li>When the <code>n</code> input is negative, <code>tail</code> returns characters starting from the n-th from the beginning of     the string. For example, if <code>n = -3</code>, then all characters except the first three are returned.</li> <li>If the length of the string has fewer than <code>n</code> characters, the full string is returned.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import pandas as pd\n&gt;&gt;&gt; import polars as pl\n&gt;&gt;&gt; import narwhals as nw\n&gt;&gt;&gt; lyrics = [\"Atatata\", \"taata\", \"taatatata\", \"zukkyun\"]\n&gt;&gt;&gt; s_pd = pd.Series(lyrics)\n&gt;&gt;&gt; s_pl = pl.Series(lyrics)\n</code></pre> <p>We define a dataframe-agnostic function:</p> <pre><code>&gt;&gt;&gt; @nw.narwhalify\n... def func(s):\n...     return s.str.tail()\n</code></pre> <p>We can then pass either pandas or Polars to <code>func</code>:</p> <pre><code>&gt;&gt;&gt; func(s_pd)\n0    atata\n1    taata\n2    atata\n3    kkyun\ndtype: object\n&gt;&gt;&gt; func(s_pl)\nshape: (4,)\nSeries: '' [str]\n[\n   \"atata\"\n   \"taata\"\n   \"atata\"\n   \"kkyun\"\n]\n</code></pre>"},{"location":"api-reference/typing/","title":"<code>narwhals.typing</code>","text":"<p>Narwhals comes fully statically typed. In addition to <code>nw.DataFrame</code>, <code>nw.Expr</code>, <code>nw.Series</code>, <code>nw.LazyFrame</code>, we also provide the following type hints:</p>"},{"location":"api-reference/typing/#dataframet","title":"<code>DataFrameT</code>","text":"<p>A <code>TypeVar</code> bound to <code>nw.DataFrame</code>. Use this when you have a function which accepts a <code>nw.DataFrame</code> and returns a <code>nw.DataFrame</code> backed by the same backend, for example:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import DataFrameT\n\n@nw.narwhalify\ndef func(df: DataFrameT) -&gt; DataFrameT:\n    return df.with_columns(c=df['a']+1)\n</code></pre>"},{"location":"api-reference/typing/#frame","title":"<code>Frame</code>","text":"<p>Either a <code>nw.DataFrame</code> or <code>nw.LazyFrame</code>. Use this if your function can work on either and your function doesn't care about its backend, for example:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import Frame\n\n@nw.narwhalify\ndef func(df: Frame) -&gt; list[str]:\n    return df.columns\n</code></pre>"},{"location":"api-reference/typing/#framet","title":"<code>FrameT</code>","text":"<p>A <code>TypeVar</code> bound to <code>Frame</code>. Use this if your function accepts either <code>nw.DataFrame</code> or <code>nw.LazyFrame</code> and returns an object backed by the same backend, for example:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.with_columns(c=nw.col('a')+1)\n</code></pre>"},{"location":"api-reference/typing/#intodataframe","title":"<code>IntoDataFrame</code>","text":"<p>An object which can be converted to <code>nw.DataFrame</code> (e.g. <code>pd.DataFrame</code>, <code>pl.DataFrame</code>). Use this if your function accepts a narwhalifiable object but doesn't care about its backend:</p> <pre><code>from __future__ import annotations\n\nimport narwhals as nw\nfrom narwhals.typing import IntoDataFrame\n\ndef func(df_native: IntoDataFrame) -&gt; tuple[int, int]:\n    df = nw.from_native(df_native, eager_only=True)\n    return df.shape\n</code></pre>"},{"location":"api-reference/typing/#intodataframet","title":"<code>IntoDataFrameT</code>","text":"<p>A <code>TypeVar</code> bound to <code>IntoDataFrame</code>. Use this if your function accepts a function which can be converted to <code>nw.DataFrame</code> and returns an object of the same class:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoDataFrameT\n\ndef func(df_native: IntoDataFrameT) -&gt; IntoDataFrameT:\n    df = nw.from_native(df_native, eager_only=True)\n    return nw.to_native(df.with_columns(c=df['a']+1))\n</code></pre>"},{"location":"api-reference/typing/#intoexpr","title":"<code>IntoExpr</code>","text":"<p>Use this to mean \"either a Narwhals expression, or something which can be converted into one\". For example, <code>exprs</code> in <code>DataFrame.select</code> is typed to accept <code>IntoExpr</code>, as it can either accept a <code>nw.Expr</code> (e.g. <code>df.select(nw.col('a'))</code>) or a string which will be interpreted as a <code>nw.Expr</code>, e.g. <code>df.select('a')</code>.</p>"},{"location":"api-reference/typing/#intoframe","title":"<code>IntoFrame</code>","text":"<p>An object which can be converted to <code>nw.DataFrame</code> or <code>nw.LazyFrame</code> (e.g. <code>pd.DataFrame</code>, <code>pl.DataFrame</code>, <code>pl.LazyFrame</code>). Use this if your function can accept an object which can be converted to either <code>nw.DataFrame</code> or <code>nw.LazyFrame</code> and it doesn't care about its backend:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrame\n\ndef func(df_native: IntoFrame) -&gt; list[str]:\n    df = nw.from_native(df_native)\n    return df.columns\n</code></pre>"},{"location":"api-reference/typing/#intoframet","title":"<code>IntoFrameT</code>","text":"<p>A <code>TypeVar</code> bound to <code>IntoFrame</code>. Use this if your function accepts an object which is convertible to <code>nw.DataFrame</code> or <code>nw.LazyFrame</code> and returns an object of the same type:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\ndef func(df_native: IntoFrameT) -&gt; IntoFrameT:\n    df = nw.from_native(df_native)\n    return nw.to_native(df.with_columns(c=nw.col('a')+1))\n</code></pre>"},{"location":"api-reference/typing/#nwnarwhalify-or-nwfrom_native","title":"<code>nw.narwhalify</code>, or <code>nw.from_native</code>?","text":"<p>Although the former is more readable, the latter is better at preserving type hints.</p> <p>Here's an example: <pre><code>import polars as pl\nimport narwhals as nw\nfrom narwhals.typing import IntoDataFrameT, DataFrameT\n\ndf = pl.DataFrame({'a': [1,2,3]})\n\ndef func(df: IntoDataFrameT) -&gt; IntoDataFrameT:\n    df = nw.from_native(df, eager_only=True)\n    return nw.to_native(df.select(b=nw.col('a')))\n\nreveal_type(func(df))\n\n@nw.narwhalify(strict=True)\ndef func_2(df: DataFrameT) -&gt; DataFrameT:\n    return df.select(b=nw.col('a'))\n\nreveal_type(func_2(df))\n</code></pre></p> <p>Running <code>mypy</code> on it gives: <pre><code>$ mypy f.py \nf.py:11: note: Revealed type is \"polars.dataframe.frame.DataFrame\"\nf.py:17: note: Revealed type is \"Any\"\nSuccess: no issues found in 1 source file\n</code></pre></p> <p>In the first case, mypy can infer that <code>df</code> is a <code>polars.DataFrame</code>. In the second case, it can't.</p> <p>If you want to make the most out of type hints and preserve them as much as possible, we recommend <code>nw.from_native</code> and <code>nw.to_native</code> - otherwise, <code>nw.narwhalify</code>. Type hints will still be respected inside the function body if you type the arguments.</p>"},{"location":"basics/column/","title":"Series","text":"<p>In dataframe, you learned how to write a dataframe-agnostic function.</p> <p>We only used DataFrame methods there - but what if we need to operate on its columns?</p> <p>Note that Polars does not have lazy columns. If you need to operate on columns as part of a dataframe operation, you should use expressions - but if you need to extract a single column, you need to ensure that you start with an eager <code>DataFrame</code>. To do that, you need to pass <code>eager_only=True</code> to <code>nw.from_native</code>.</p>"},{"location":"basics/column/#example-1-filter-based-on-a-columns-values","title":"Example 1: filter based on a column's values","text":"<p>This can stay lazy, so we just use <code>nw.from_native</code> and expressions:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n@nw.narwhalify\ndef my_func(df: FrameT) -&gt; FrameT:\n    return df.filter(nw.col('a') &gt; 0)\n</code></pre> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b\n1  1  5\n2  3 -3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 5   \u2502\n\u2502 3   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 5   \u2502\n\u2502 3   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/column/#example-2-multiply-a-columns-values-by-a-constant","title":"Example 2: multiply a column's values by a constant","text":"<p>Let's write a dataframe-agnostic function which multiplies the values in column <code>'a'</code> by 2. This can also stay lazy, and can use expressions:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n@nw.narwhalify\ndef my_func(df: FrameT) -&gt; FrameT:\n    return df.with_columns(nw.col('a')*2)\n</code></pre> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b\n0 -2  3\n1  2  5\n2  6 -3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -2  \u2506 3   \u2502\n\u2502 2   \u2506 5   \u2502\n\u2502 6   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -2  \u2506 3   \u2502\n\u2502 2   \u2506 5   \u2502\n\u2502 6   \u2506 -3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Note that column <code>'a'</code> was overwritten. If we had wanted to add a new column called <code>'c'</code> containing column <code>'a'</code>'s values multiplied by 2, we could have used <code>Expr.alias</code>:</p> <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n@nw.narwhalify\ndef my_func(df: FrameT) -&gt; FrameT:\n    return df.with_columns((nw.col('a')*2).alias('c'))\n</code></pre> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>   a  b  c\n0 -1  3 -2\n1  1  5  2\n2  3 -3  6\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1  \u2506 3   \u2506 -2  \u2502\n\u2502 1   \u2506 5   \u2506 2   \u2502\n\u2502 3   \u2506 -3  \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df).collect())\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 c   \u2502\n\u2502 --- \u2506 --- \u2506 --- \u2502\n\u2502 i64 \u2506 i64 \u2506 i64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1  \u2506 3   \u2506 -2  \u2502\n\u2502 1   \u2506 5   \u2506 2   \u2502\n\u2502 3   \u2506 -3  \u2506 6   \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/column/#example-3-finding-the-mean-of-a-column-as-a-scalar","title":"Example 3: finding the mean of a column as a scalar","text":"<p>Now, we want to find the mean of column <code>'a'</code>, and we need it as a Python scalar. This means that computation cannot stay lazy - it must execute! Therefore, we'll pass <code>eager_only=True</code> to <code>nw.narwhalify</code>, and then, instead of using expressions, we'll extract a <code>Series</code>.</p> <pre><code>from __future__ import annotations\nimport narwhals as nw\n\n@nw.narwhalify(eager_only=True)\ndef my_func(df: nw.DataFrame) -&gt; float | None:\n    return df['a'].mean()\n</code></pre> pandasPolars (eager) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>1.0\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [-1, 1, 3], 'b': [3, 5, -3]})\nprint(my_func(df))\n</code></pre> <pre><code>1.0\n</code></pre> <p>Note that, even though the output of our function is not a dataframe nor a series, we can still use <code>narwhalify</code>.</p>"},{"location":"basics/complete_example/","title":"Complete example","text":"<p>We're going to write a dataframe-agnostic \"Standard Scaler\". This class will have <code>fit</code> and <code>transform</code> methods (like <code>scikit-learn</code> transformers), and will work agnostically for pandas and Polars.</p> <p>We'll need to write two methods:</p> <ul> <li><code>fit</code>: find the mean and standard deviation for each column from a given training set;</li> <li><code>transform</code>: scale a given dataset with the mean and standard deviations calculated   during <code>fit</code>.</li> </ul> <p>The <code>fit</code> method is a bit complicated, so let's start with <code>transform</code>. Suppose we've already calculated the mean and standard deviation of each column, and have stored them in attributes <code>self.means</code> and <code>self.std_devs</code>.</p>"},{"location":"basics/complete_example/#fit-method","title":"Fit method","text":"<p>Unlike the <code>transform</code> method, which we'll write below, <code>fit</code> cannot stay lazy, as we need to compute concrete values for the means and standard deviations.</p> <p>To be able to get <code>Series</code> out of our <code>DataFrame</code>, we'll pass <code>eager_only=True</code> to <code>nw.from_native</code>. This is because Polars doesn't have a concept of lazy <code>Series</code>, and so Narwhals doesn't either.</p> <p>We can specify that in the <code>@nw.narwhalify</code> decorator by setting <code>eager_only=True</code>, and the argument will be propagated to <code>nw.from_native</code>.</p> <pre><code>import narwhals as nw\nfrom typing import Any\n\nclass StandardScaler:\n    @nw.narwhalify(eager_only=True)\n    def fit(self, df: nw.DataFrame[Any]) -&gt; None:\n        self._means = {col: df[col].mean() for col in df.columns}\n        self._std_devs = {col: df[col].std() for col in df.columns}\n</code></pre>"},{"location":"basics/complete_example/#transform-method","title":"Transform method","text":"<p>We're going to take in a dataframe, and return a dataframe of the same type. Therefore, we use <code>@nw.narwhalify</code>:</p> <pre><code>    @nw.narwhalify\n    def transform(self, df: FrameT) -&gt; FrameT:\n        return df.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in df.columns\n        )\n</code></pre> <p>Note that all the calculations here can stay lazy if the underlying library permits it, so we don't pass in any extra keyword-arguments such as <code>eager_only</code>, we just use the default <code>eager_only=False</code>.</p>"},{"location":"basics/complete_example/#putting-it-all-together","title":"Putting it all together","text":"<p>Here is our dataframe-agnostic standard scaler: <pre><code>from typing import Any\n\nimport narwhals as nw\nfrom narwhals.typing import FrameT\n\nclass StandardScaler:\n    @nw.narwhalify(eager_only=True)\n    def fit(self, df: nw.DataFrame[Any]) -&gt; None:\n        self._means = {col: df[col].mean() for col in df.columns}\n        self._std_devs = {col: df[col].std() for col in df.columns}\n\n    @nw.narwhalify\n    def transform(self, df: FrameT) -&gt; FrameT:\n        return df.with_columns(\n            (nw.col(col) - self._means[col]) / self._std_devs[col]\n            for col in df.columns\n        )\n</code></pre></p> <p>Next, let's try running it. Notice how, as <code>transform</code> doesn't use any eager-only features, so we can pass a Polars LazyFrame to it and have it stay lazy!</p> pandasPolars <pre><code>import pandas as pd\n\ndf_train = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 7]})\ndf_test = pd.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 7]})\nscaler = StandardScaler()\nscaler.fit(df_train)\nprint(scaler.transform(df_test))\n</code></pre> <pre><code>     a         b\n0 -1.0 -0.872872\n1  0.0 -0.218218\n2  1.0  1.091089\n</code></pre> <pre><code>import polars as pl\n\ndf_train = pl.DataFrame({'a': [1, 2, 3], 'b': [4, 5, 7]})\ndf_test = pl.LazyFrame({'a': [1, 2, 3], 'b': [4, 5, 7]})\nscaler = StandardScaler()\nscaler.fit(df_train)\nprint(scaler.transform(df_test).collect())\n</code></pre> <pre><code>shape: (3, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a    \u2506 b         \u2502\n\u2502 ---  \u2506 ---       \u2502\n\u2502 f64  \u2506 f64       \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 -1.0 \u2506 -0.872872 \u2502\n\u2502 0.0  \u2506 -0.218218 \u2502\n\u2502 1.0  \u2506 1.091089  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/dataframe/","title":"DataFrame","text":"<p>To write a dataframe-agnostic function, the steps you'll want to follow are:</p> <ol> <li> <p>Initialise a Narwhals DataFrame or LazyFrame by passing your dataframe to <code>nw.from_native</code>.     All the calculations stay lazy if we start with a lazy dataframe - Narwhals will never automatically trigger computation without you asking it to.</p> <p>Note: if you need eager execution, make sure to pass <code>eager_only=True</code> to <code>nw.from_native</code>.</p> </li> <li> <p>Express your logic using the subset of the Polars API supported by Narwhals.</p> </li> <li>If you need to return a dataframe to the user in its original library, call <code>nw.to_native</code>.</li> </ol> <p>Steps 1 and 3 are so common that we provide a utility <code>@nw.narwhalify</code> decorator, which allows you to only explicitly write step 2.</p> <p>Let's explore this with some simple examples.</p>"},{"location":"basics/dataframe/#example-1-descriptive-statistics","title":"Example 1: descriptive statistics","text":"<p>Just like in Polars, we can pass expressions to <code>DataFrame.select</code> or <code>LazyFrame.select</code>.</p> <p>Make a Python file with the following content: <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.select(\n        a_sum=nw.col('a').sum(),\n        a_mean=nw.col('a').mean(),\n        a_std=nw.col('a').std(),\n    )\n</code></pre> Let's try it out:</p> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [1, 1, 2]})\nprint(func(df))\n</code></pre> <pre><code>   a_sum    a_mean    a_std\n0      4  1.333333  0.57735\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [1, 1, 2]})\nprint(func(df))\n</code></pre> <pre><code>shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_sum \u2506 a_mean   \u2506 a_std   \u2502\n\u2502 ---   \u2506 ---      \u2506 ---     \u2502\n\u2502 i64   \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4     \u2506 1.333333 \u2506 0.57735 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [1, 1, 2]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (1, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a_sum \u2506 a_mean   \u2506 a_std   \u2502\n\u2502 ---   \u2506 ---      \u2506 ---     \u2502\n\u2502 i64   \u2506 f64      \u2506 f64     \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 4     \u2506 1.333333 \u2506 0.57735 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <p>Alternatively, we could have opted for the more explicit version: <pre><code>import narwhals as nw\nfrom narwhals.typing import IntoFrameT\n\ndef func(df_native: IntoFrameT) -&gt; IntoFrameT:\n    df = nw.from_native(df_native)\n    df = df.select(\n        a_sum=nw.col('a').sum(),\n        a_mean=nw.col('a').mean(),\n        a_std=nw.col('a').std(),\n    )\n    return nw.to_native(df)\n</code></pre> Despite being more verbose, it has the advantage of preserving the type annotation of the native object - see typing for more details.</p> <p>In general, in this tutorial, we'll use the former.</p>"},{"location":"basics/dataframe/#example-2-group-by-and-mean","title":"Example 2: group-by and mean","text":"<p>Just like in Polars, we can pass expressions to <code>GroupBy.agg</code>. Make a Python file with the following content: <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.group_by('a').agg(nw.col('b').mean()).sort('a')\n</code></pre> Let's try it out:</p> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>   a    b\n0  1  4.5\n1  2  6.0\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4.5 \u2502\n\u2502 2   \u2506 6.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (2, 2)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2502\n\u2502 --- \u2506 --- \u2502\n\u2502 i64 \u2506 f64 \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4.5 \u2502\n\u2502 2   \u2506 6.0 \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/dataframe/#example-3-horizontal-sum","title":"Example 3: horizontal sum","text":"<p>Expressions can be free-standing functions which accept other expressions as inputs. For example, we can compute a horizontal sum using <code>nw.sum_horizontal</code>.</p> <p>Make a Python file with the following content: <pre><code>import narwhals as nw\nfrom narwhals.typing import FrameT\n\n@nw.narwhalify\ndef func(df: FrameT) -&gt; FrameT:\n    return df.with_columns(a_plus_b=nw.sum_horizontal('a', 'b'))\n</code></pre> Let's try it out:</p> pandasPolars (eager)Polars (lazy) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>   a  b  a_plus_b\n0  1  4         5\n1  1  5         6\n2  2  6         8\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df))\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 a_plus_b \u2502\n\u2502 --- \u2506 --- \u2506 ---      \u2502\n\u2502 i64 \u2506 i64 \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4   \u2506 5        \u2502\n\u2502 1   \u2506 5   \u2506 6        \u2502\n\u2502 2   \u2506 6   \u2506 8        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.LazyFrame({'a': [1, 1, 2], 'b': [4, 5, 6]})\nprint(func(df).collect())\n</code></pre> <pre><code>shape: (3, 3)\n\u250c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502 a   \u2506 b   \u2506 a_plus_b \u2502\n\u2502 --- \u2506 --- \u2506 ---      \u2502\n\u2502 i64 \u2506 i64 \u2506 i64      \u2502\n\u255e\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2561\n\u2502 1   \u2506 4   \u2506 5        \u2502\n\u2502 1   \u2506 5   \u2506 6        \u2502\n\u2502 2   \u2506 6   \u2506 8        \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n</code></pre>"},{"location":"basics/dataframe/#example-4-multiple-inputs","title":"Example 4: multiple inputs","text":"<p><code>nw.narwhalify</code> can be used to decorate functions that take multiple inputs as well and return a non dataframe/series-like object.</p> <p>For example, let's compute how many rows are left in a dataframe after filtering it based on a series.</p> <p>Make a Python file with the following content: <pre><code>from typing import Any\n\nimport narwhals as nw\n\n@nw.narwhalify(eager_only=True)\ndef func(df: nw.DataFrame[Any], s: nw.Series, col_name: str) -&gt; int:\n    return df.filter(nw.col(col_name).is_in(s)).shape[0]\n</code></pre></p> <p>We require <code>eager_only=True</code> here because lazyframe doesn't support <code>.shape</code>.</p> <p>Let's try it out:</p> pandasPolars (eager) <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [1, 1, 2, 2, 3], 'b': [4, 5, 6, 7, 8]})\ns = pd.Series([1, 3])\nprint(func(df, s.to_numpy(), 'a'))\n</code></pre> <pre><code>3\n</code></pre> <pre><code>import polars as pl\n\ndf = pl.DataFrame({'a': [1, 1, 2, 2, 3], 'b': [4, 5, 6, 7, 8]})\ns = pl.Series([1, 3])\nprint(func(df, s.to_numpy(), 'a'))\n</code></pre> <pre><code>3\n</code></pre>"},{"location":"other/pandas_index/","title":"What about the pandas Index?","text":"<p>There are two types of pandas users:</p> <ul> <li>The ones who make full use of the Index's power.</li> <li>The <code>.reset_index(drop=True)</code> ones, who would rather not think about the Index.</li> </ul> <p>Narwhals aims to accommodate both!</p> <ul> <li>If you'd rather not think about the Index, then don't   worry: it's not part of the Narwhals public API, and you'll never have to worry about   resetting the index or about pandas doing funky index alignment for you.</li> <li>If you want your library to cater to Index powerusers who would be very angry if you reset   their beautiful Index on their behalf, then don't worry: Narwhals makes certain promises   with regards to the Index.</li> </ul> <p>Let's learn about what Narwhals promises.</p>"},{"location":"other/pandas_index/#1-narwhals-will-preserve-your-index-for-dataframe-operations","title":"1. Narwhals will preserve your index for dataframe operations","text":"<pre><code>import narwhals as nw\n\ndef my_func(df):\n    df = nw.from_native(df)\n    df = df.with_columns(a_plus_one=nw.col('a')+1)\n    return nw.to_native(df)\n</code></pre> <p>Let's start with a dataframe with an Index with values <code>[7, 8, 9]</code>.</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({'a': [2, 1, 3], 'b': [3, 5, -3]}, index=[7, 8, 9])\nprint(my_func(df))\n</code></pre> <pre><code>   a  b  a_plus_one\n7  2  3           3\n8  1  5           2\n9  3 -3           4\n</code></pre> <p>Note how the result still has the original index - Narwhals did not modify it.</p>"},{"location":"other/pandas_index/#2-index-alignment-follows-the-left-hand-rule","title":"2. Index alignment follows the left-hand-rule","text":"<p>pandas automatically aligns indices for users. For example:</p> <p><pre><code>import pandas as pd\n\ndf_pd = pd.DataFrame({'a': [2, 1, 3], 'b': [4, 5, 6]})\ns_pd = df_pd['a'].sort_values()\ndf_pd['a_sorted'] = s_pd\n</code></pre> Reading the code, you might expect that <code>'a_sorted'</code> will contain the values <code>[1, 2, 3]</code>.</p> <p>However, here's what actually happens: <pre><code>print(df_pd)\n</code></pre> <pre><code>   a  b  a_sorted\n0  2  4         2\n1  1  5         1\n2  3  6         3\n</code></pre>  In other words, pandas' index alignment undid the <code>sort_values</code> operation!</p> <p>Narwhals, on the other hand, preserves the index of the left-hand-side argument. Everything else will be inserted positionally, just like Polars would do:</p> <pre><code>import narwhals as nw\n\ndf = nw.from_native(df_pd)\ns = nw.from_native(s_pd, allow_series=True)\ndf = df.with_columns(a_sorted=s.sort())\nprint(nw.to_native(df))\n</code></pre> <pre><code>   a  b  a_sorted\n0  2  4         1\n1  1  5         2\n2  3  6         3\n</code></pre> <p>If you keep these two rules in mind, then Narwhals will both help you avoid Index-related surprises whilst letting you preserve the Index for the subset of your users who consciously make great use of it.</p>"}]}